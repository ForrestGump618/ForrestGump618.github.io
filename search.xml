<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World！</title>
    <url>/2023/08/10/Hello%20World%EF%BC%81/</url>
    <content><![CDATA[<p>&emsp;&emsp;欢迎来到我的主页，这里将记录我学习医学、统计和流行病学的一些收获，以及一些生活碎片。欢迎来踩！<br>&emsp;&emsp;希望这些笔记对您的学习有帮助，最好的东西是免费的，最好的知识是开源的。<br>2023年8月11日</p>
]]></content>
  </entry>
  <entry>
    <title>celltogwas：细胞类型注释到基因组的工具包</title>
    <url>/2023/08/19/celltogwas%EF%BC%9A%E7%BB%86%E8%83%9E%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A%E5%88%B0%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
    <content><![CDATA[<h2 id="celltogwas"><a href="#celltogwas" class="headerlink" title="celltogwas"></a>celltogwas</h2><p>This code is a toolkit for genomic analysis. It includes several functions and helper functions to extract gene information from a genomic annotation file, merge gene intervals, generate genomic ranges based on cell types and window size, and annotate GWAS (Genome-Wide Association Study) data.</p>
<h2 id="Explanation-of-each-function"><a href="#Explanation-of-each-function" class="headerlink" title="Explanation of each function"></a>Explanation of each function</h2><p><strong>extract_gene_info(gtf_file)</strong>: Extracts gene information from a genomic annotation file. It opens a gzip-compressed file, reads it line by line, and extracts gene name, chromosome, start position, and end position from each line. The extracted data is then stored in a Pandas DataFrame and returned.</p>
<p><strong>merge_intervals(intervals)</strong>: Merges overlapping intervals. This function takes a list of intervals as input and merges overlapping intervals into larger intervals. It first sorts the intervals based on their start positions, then iterates through the intervals. If the current interval does not overlap with the merged interval, it adds the current interval to the merged list. Otherwise, it updates the end position of the merged interval. Finally, it returns the merged interval list.</p>
<p><strong>celltype_genome_range(cell_gene_dict, gene_info, windowsize)</strong>: Generates genomic ranges based on cell types and window size. This function takes a dictionary mapping cell types to gene lists, a DataFrame of gene information, and a window size as input. It retrieves the gene list corresponding to each cell type from the dictionary and performs an inner join with the gene information to obtain the chromosome, start position, and end position of the corresponding genes. It then adjusts the start and end positions based on the window size and converts the data into a specific format of a list. Finally, it stores the genomic ranges for each cell type in a dictionary and returns it.</p>
<p><strong>check_value_in_intervals(intervals, value)</strong>: Checks if a value is within the intervals. This function takes a list of intervals and a value as input. It uses binary search to determine if the value falls within the intervals. It first extracts the left boundaries of the intervals, then performs a binary search to find the position of the value in the left boundary list. If the position is less than the length of the interval list, it retrieves the corresponding interval and checks if the value falls within that interval. If the value is within the interval, it returns True; otherwise, it returns False.</p>
<p><strong>gwas_annotaion(gwas, celltype_range)</strong>: Annotates GWAS data based on genomic ranges. This function takes a DataFrame of GWAS data and a dictionary of genomic ranges as input. It first retrieves the list of chromosomes from the GWAS data. Then, it iterates through the genomic ranges for each cell type. For each chromosome, it retrieves the subset of GWAS data corresponding to that chromosome and the annotation ranges from the genomic ranges. It then iterates through each data item in the subset and uses the check_value_in_intervals function to check if the position of the data item falls within the annotation ranges. If it does, the data item is marked as annotated. Finally, it stores the annotation results for all cell types in a dictionary and returns it.</p>
<h2 id="File-format"><a href="#File-format" class="headerlink" title="File format"></a><a href="#File-format" title="File format"></a>File format</h2><p><strong>gtf_file</strong>: Include CHR, START, END, Other info(GENE Symbol);</p>
<p><strong>cell_gene_dict</strong>: A dictionary:(1) key:celltype’s name;(2)value:a list of genes;</p>
<p><strong>gene_info</strong>: Output file from <strong>extract_gene_info(gtf_file)</strong>: Include: GENE, CHR, START, END;</p>
<p><strong>gwas</strong>: First teo columns: chr, pos;</p>
<p><strong>celltype_range</strong>: A dictionary:(1) key:celltype’s name;(2)value:a list of genome position:[chr, start, end];</p>
<p><strong>output_file</strong>: A dictionary:(1) key:celltype’s name;(2)value:[chr, pos ,…… , annotation] (annotation: 1 for anntation and 0 for null).</p>
]]></content>
      <categories>
        <category>生物信息学</category>
      </categories>
      <tags>
        <tag>GWAS</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>scDRS：基于GWAS和scRNA评估细胞类型和生物学过程的疾病相关性</title>
    <url>/2023/08/11/scDRS%EF%BC%9A%E5%9F%BA%E4%BA%8EGWAS%E5%92%8CscRNA%E8%AF%84%E4%BC%B0%E7%BB%86%E8%83%9E%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%94%9F%E7%89%A9%E5%AD%A6%E8%BF%87%E7%A8%8B%E7%9A%84%E7%96%BE%E7%97%85%E7%9B%B8%E5%85%B3%E6%80%A7/</url>
    <content><![CDATA[<h2 id="方法学概述"><a href="#方法学概述" class="headerlink" title="方法学概述"></a>方法学概述</h2><p>&emsp;&emsp;scDRS的核心思想是建立合适的权重从而根据基因的表达对基因程序进行评分，即加权基因表达量。其算法可概述为：首先将基因根据MAGMA得到的gene-level z-scores从大到小排列（也可以自定义基因程序）, 选择潜在的致病基因。基于致病基因的表达量和权重接着计算致病基因程序加权表达量。从而评估该细胞的基因程序和疾病的相关度。<br>&emsp;&emsp;算法对z-score采用算数加权，对技术噪声指标采用逆加权。也就是说，在GWAS中鉴定出的越相关的，且测序过程中技术原因造成误差较小的基因。根据输入数据集的基因表达，在蒙特卡洛随机模拟生成的B个对照组中，从而推断分布，进而对研究的疾病进行统计检验。利用这样的方法，我们可以计算单个细胞和疾病的相关性，以及鉴定相应的驱动基因，并基于此进行下游分析。</p>
<h2 id="使用scdrs包在Python中进行分析"><a href="#使用scdrs包在Python中进行分析" class="headerlink" title="使用scdrs包在Python中进行分析"></a>使用scdrs包在Python中进行分析</h2><h3 id="载入程序包"><a href="#载入程序包" class="headerlink" title="载入程序包"></a>载入程序包</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scanpy <span class="keyword">as</span> sc</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> scdrs</span><br></pre></td></tr></table></figure>
<h3 id="基础参数设置"><a href="#基础参数设置" class="headerlink" title="基础参数设置"></a>基础参数设置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sc.settings.verbosity = <span class="number">3</span> <span class="comment"># 设置日志等级:errors(0),warnings(1),info(2),hints(3)  </span></span><br><span class="line">sc.logging.print_header() <span class="comment"># 输出版本号</span></span><br><span class="line">sc.settings.set_figure_params(dpi=<span class="number">300</span>, facecolor=<span class="string">&#x27;white&#x27;</span>) <span class="comment"># 设置图片的分辨率300dpi</span></span><br></pre></td></tr></table></figure>
<h3 id="读取计数矩阵和预处理"><a href="#读取计数矩阵和预处理" class="headerlink" title="读取计数矩阵和预处理"></a>读取计数矩阵和预处理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">adata = sc.read_csv(<span class="string">&quot;heart.csv&quot;</span>) <span class="comment"># 注意，这里的heart.csv列为细胞，行为基因，这一点和seurat框架是不同的。</span></span><br><span class="line"><span class="comment"># 其他的读取方法可参考scanpy的文档。</span></span><br><span class="line">adata.var_names_make_unique()</span><br><span class="line">adata.obs_names_make_unique()</span><br><span class="line">adata.var.head() <span class="comment"># 基因特征的摘要</span></span><br><span class="line">adata.obs.head() <span class="comment"># 细胞特征的摘要</span></span><br><span class="line">adata <span class="comment"># 返回矩阵大小，基因相关的变量以及细胞相关的变量数据  </span></span><br><span class="line">sc.pl.highest_expr_genes(adata, n_top=<span class="number">20</span>) <span class="comment"># 显示在全部单个细胞中基因读数占总读数的百分比排名前20的基因</span></span><br></pre></td></tr></table></figure>
<h3 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h3><p>&emsp;&emsp;质量控制，大部分都是针对细胞（obs）的质量控制。<br>&emsp;&emsp;细胞质控通常对以下三个质控协变量进行：  </p>
<ol>
<li>每个条形码的计数数量（计数深度）  </li>
<li>每个条形码的基因数量  </li>
<li>每个条形码的线粒体基因计数比例<br>&emsp;&emsp;如果一个细胞正在死亡，其mRNA被释放到内环境，导致线粒体基因的比例较高，所以我们可以通过线粒体基因的比例来过滤掉低质量的单细胞测序数据。但是如果仅考虑一个变量可能会造成生物学误差，共同考虑三个 QC 协变量至关重要。例如，线粒体计数相对较高的细胞可能参与呼吸过程，不应被过滤掉。然而，计数低或高的细胞可能对应于静止细胞群或尺寸较大的细胞。故我们在过滤低质量细胞的时候，要同时考虑不同的QC协变量之间的关系。</li>
</ol>
<h3 id="质控指标的计算"><a href="#质控指标的计算" class="headerlink" title="质控指标的计算"></a>质控指标的计算</h3><p>&emsp;&emsp;首先采用正则表达式识别线粒体；接着，我们将根据识别的结果进行比例的计算。<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">adata.var[<span class="string">&quot;mt&quot;</span>] = adata.var_names.<span class="built_in">str</span>.startswith(<span class="string">&quot;MT-&quot;</span>)  </span><br><span class="line">sc.pp.calculate_qc_metrics(adata, qc_vars=[<span class="string">&quot;mt&quot;</span>], inplace=<span class="literal">True</span>, percent_top=[<span class="number">20</span>], log1p=<span class="literal">True</span>) <span class="comment"># 此处可以计算其他给定基因；该步骤之后，才可以得到n_counts等数据。</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;通过上面的计算和adata.obs固有的数据，我们可以得到三个质控协变量：  </p>
<ol>
<li>n_genes_by_counts/detected_genes: 一个细胞中发现的有效基因数量（即表达量不为0）  </li>
<li>total_counts/nUMIs: 一个细胞中发现的分子数量（UMI），通常也可以被认为是这个细胞的文库大小  </li>
<li>pct_counts_mt/mito_perc: 一个细胞中线粒体基因的表达计数占比<br>&emsp;&emsp;可以绘制三个协变量的分布图。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">mito_filter = <span class="number">25</span> <span class="comment"># 根据数据集合设定，注意，心室肌等组织富含线粒体，需要根据情况进行更改。</span></span><br><span class="line">n_counts_filter = <span class="number">4300</span> <span class="comment"># 根据上述的MAD方法进行设定，官方教程认为counts数过多可能是双细胞，但是下面采用scrublet方法进行双细胞识别。</span></span><br><span class="line">fig, axs = plt.subplots(ncols = <span class="number">2</span>, figsize = (<span class="number">8</span>,<span class="number">4</span>))</span><br><span class="line">sc.pl.scatter(adata, x=<span class="string">&#x27;total_counts&#x27;</span>, y=<span class="string">&#x27;pct_counts_mt&#x27;</span>,ax = axs[<span class="number">0</span>], show=<span class="literal">False</span>)  </span><br><span class="line">sc.pl.scatter(adata, x=<span class="string">&#x27;total_counts&#x27;</span>, y=<span class="string">&#x27;n_genes_by_counts&#x27;</span>,ax = axs[<span class="number">1</span>], show = <span class="literal">False</span>) </span><br><span class="line"><span class="comment"># draw horizontal red lines indicating thresholds.</span></span><br><span class="line">axs[<span class="number">0</span>].hlines(y = mito_filter, xmin = <span class="number">0</span>, xmax = <span class="built_in">max</span>(adata.obs[<span class="string">&#x27;total_counts&#x27;</span>]), color = <span class="string">&#x27;red&#x27;</span>, ls = <span class="string">&#x27;dashed&#x27;</span>) </span><br><span class="line">axs[<span class="number">1</span>].hlines(y = n_counts_filter, xmin = <span class="number">0</span>, xmax = <span class="built_in">max</span>(adata.obs[<span class="string">&#x27;total_counts&#x27;</span>]), color = <span class="string">&#x27;red&#x27;</span>, ls = <span class="string">&#x27;dashed&#x27;</span>)</span><br><span class="line">fig.tight_layout()  </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;也可以采用小提琴图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sc.pl.violin(adata, [<span class="string">&#x27;n_genes_by_counts&#x27;</span>, <span class="string">&#x27;total_counts&#x27;</span>, <span class="string">&#x27;pct_counts_mt&#x27;</span>],jitter=<span class="number">0.4</span>, multi_panel=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;还可以采用直方图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns  </span><br><span class="line">sns.histplot(adata.obs[<span class="string">&quot;n_genes_by_counts&quot;</span>], bins=<span class="number">100</span>, kde=<span class="literal">False</span>)  </span><br><span class="line">sns.histplot(adata.obs[<span class="string">&quot;total_counts&quot;</span>], bins=<span class="number">100</span>, kde=<span class="literal">False</span>) </span><br></pre></td></tr></table></figure>
<h3 id="双细胞过滤"><a href="#双细胞过滤" class="headerlink" title="双细胞过滤"></a>双细胞过滤</h3><p>&emsp;&emsp;双细胞被定义为在相同的细胞条形码（barcode）下进行测序的两个细胞，例如，如果它们被捕获在同一个液滴（droplet）中。双细胞由同型（homotypic）与异型（heterotypic）所构成 ：</p>
<ol>
<li>同型：同型通常被认为是不影响下游分析的，因为其是由一类相同的细胞中的两个所构成，所以这部分细胞不是我们所需要过滤的对象；  </li>
<li>异型：异型通常是由来自两类不同的细胞所构成的，异型的存在会使得我们后续的细胞分类出现错误，因为其独特的数据分布特征。<br>&emsp;&emsp;我们可以通过人工构建双细胞进行模拟识别，以排除异型的存在。我们将使用scrublet来完成双细胞的识别。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sc.external.pp.scrublet(adata, random_state=<span class="number">112</span>) </span><br><span class="line">adata = adata[adata.obs[<span class="string">&#x27;predicted_doublet&#x27;</span>]==<span class="literal">False</span>, :]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="低质量细胞过滤"><a href="#低质量细胞过滤" class="headerlink" title="低质量细胞过滤"></a>低质量细胞过滤</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">adata = adata[adata.obs.pct_counts_mt &lt; <span class="number">25</span>, :]  </span><br><span class="line">adata = adata[adata.obs.n_genes_by_counts &gt; <span class="number">200</span>, :]  </span><br><span class="line">adata = adata[adata.obs.total_counts &gt; <span class="number">300</span>, :]  </span><br><span class="line">sc.pp.filter_cells(adata, min_genes=<span class="number">200</span>)  </span><br><span class="line">sc.pp.filter_genes(adata, min_cells=<span class="number">3</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 小提琴图可视化  </span></span><br><span class="line">sc.pl.violin(adata, [<span class="string">&#x27;n_genes_by_counts&#x27;</span>, <span class="string">&#x27;total_counts&#x27;</span>, <span class="string">&#x27;pct_counts_mt&#x27;</span>],jitter=<span class="number">0.4</span>, multi_panel=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="保存结果用于scDRS的分析"><a href="#保存结果用于scDRS的分析" class="headerlink" title="保存结果用于scDRS的分析"></a>保存结果用于scDRS的分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">adata_raw = adata.copy()  </span><br><span class="line">adata_raw.write_h5ad(<span class="string">f&quot;./output/<span class="subst">&#123;sample&#125;</span>/expr.h5ad&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">df_cov = pd.DataFrame(index=adata_raw.obs.index)  </span><br><span class="line">df_cov[<span class="string">&quot;const&quot;</span>] = <span class="number">1</span>  </span><br><span class="line">df_cov[<span class="string">&quot;n_genes&quot;</span>] = adata_raw.obs[<span class="string">&quot;n_genes&quot;</span>]  </span><br><span class="line">df_cov.to_csv(<span class="string">f&quot;./output/<span class="subst">&#123;sample&#125;</span>/cov.tsv&quot;</span>, sep=<span class="string">&quot;\t&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">summary = pd.DataFrame(adata_raw.obs)  </span><br><span class="line">summary.to_csv(<span class="string">f&quot;./output/<span class="subst">&#123;sample&#125;</span>/summary.tsv&quot;</span>, sep=<span class="string">&quot;\t&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="scDRS分析"><a href="#scDRS分析" class="headerlink" title="scDRS分析"></a>scDRS分析</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">adata = scdrs.util.load_h5ad(h5ad_file=<span class="string">f&quot;./output/<span class="subst">&#123;sample&#125;</span>/expr.h5ad&quot;</span>, flag_filter_data=<span class="literal">False</span>, flag_raw_count=<span class="literal">True</span>)  </span><br><span class="line">dict_gs = scdrs.util.load_gs(<span class="string">&quot;./output/CHD.gs&quot;</span>, src_species=<span class="string">&quot;human&quot;</span>, dst_species=<span class="string">&quot;human&quot;</span>,to_intersect=adata.var_names)  </span><br><span class="line">df_cov = pd.read_csv(<span class="string">f&quot;./output/<span class="subst">&#123;sample&#125;</span>/cov.tsv&quot;</span>, sep=<span class="string">&quot;\t&quot;</span>, index_col=<span class="number">0</span>)  </span><br><span class="line">adata_analysis = scdrs.preprocess(adata, cov=df_cov, n_mean_bin=<span class="number">20</span>, n_var_bin=<span class="number">20</span>, copy=<span class="literal">True</span>)  </span><br><span class="line">dict_df_score = <span class="built_in">dict</span>()  </span><br><span class="line"><span class="keyword">for</span> trait <span class="keyword">in</span> dict_gs:  </span><br><span class="line">	gene_list, gene_weights = dict_gs[trait]  </span><br><span class="line">	dict_df_score[trait] = scdrs.score_cell(  </span><br><span class="line">		data=adata_analysis,  </span><br><span class="line">		gene_list=gene_list,  </span><br><span class="line">		gene_weight=gene_weights,  </span><br><span class="line">		ctrl_match_key=<span class="string">&quot;mean_var&quot;</span>,  </span><br><span class="line">		n_ctrl=<span class="number">1000</span>,  </span><br><span class="line">		weight_opt=<span class="string">&quot;vs&quot;</span>,  </span><br><span class="line">		return_ctrl_raw_score=<span class="literal">False</span>,  </span><br><span class="line">		return_ctrl_norm_score=<span class="literal">True</span>,  </span><br><span class="line">		verbose=<span class="literal">False</span>,  </span><br><span class="line">	)  </span><br><span class="line">chd = dict_df_score[<span class="string">&quot;CHD&quot;</span>]  </span><br><span class="line">chd.to_csv(<span class="string">f&quot;./output/<span class="subst">&#123;sample&#125;</span>/CHD.csv&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sc.pp.highly_variable_genes(adata, n_top_genes=<span class="number">2000</span>)  </span><br><span class="line">adata = adata[:, adata.var.highly_variable]  </span><br><span class="line">sc.pp.regress_out(adata, [<span class="string">&#x27;total_counts&#x27;</span>, <span class="string">&#x27;pct_counts_mt&#x27;</span>])  </span><br><span class="line"><span class="comment">#归一化 (事实上，只有PCA才采用归一化数据，使得不同PC的数据规模接近。)  </span></span><br><span class="line">sc.pp.scale(adata, max_value=<span class="number">10</span>)  </span><br><span class="line"><span class="comment">#主成分分析  </span></span><br><span class="line">sc.tl.pca(adata, svd_solver=<span class="string">&quot;arpack&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">sc.pp.neighbors(adata, n_neighbors=<span class="number">10</span>, n_pcs=<span class="number">40</span>) <span class="comment">#KNN算法，此处参数：n_neighbours更大，则聚类可能会变少；n_pcs一般为40，可参考碎石图。  </span></span><br><span class="line">sc.tl.umap(adata)  </span><br><span class="line">sc.tl.leiden(adata)  </span><br><span class="line">sc.pl.umap(adata, color=[<span class="string">&#x27;leiden&#x27;</span>],save=<span class="string">f&quot;<span class="subst">&#123;sample&#125;</span>_original.png&quot;</span>)  </span><br><span class="line"><span class="comment">#非参数检验方法  </span></span><br><span class="line">sc.tl.rank_genes_groups(adata, <span class="string">&#x27;leiden&#x27;</span>, method=<span class="string">&#x27;wilcoxon&#x27;</span>)  </span><br><span class="line">sc.pl.rank_genes_groups(adata, n_genes=<span class="number">25</span>, sharey=<span class="literal">False</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 结果写入，方便后续可视化  </span></span><br><span class="line">pd.DataFrame(adata.uns[<span class="string">&#x27;rank_genes_groups&#x27;</span>][<span class="string">&#x27;names&#x27;</span>]).head(<span class="number">5</span>)  </span><br><span class="line">result = adata.uns[<span class="string">&#x27;rank_genes_groups&#x27;</span>]  </span><br><span class="line">groups = result[<span class="string">&#x27;names&#x27;</span>].dtype.names  </span><br><span class="line">pd.DataFrame(adata.uns[<span class="string">&#x27;rank_genes_groups&#x27;</span>][<span class="string">&#x27;names&#x27;</span>]).to_csv(<span class="string">f&quot;./output/<span class="subst">&#123;sample&#125;</span>/marker.csv&quot;</span>)  </span><br><span class="line"><span class="keyword">for</span> trait <span class="keyword">in</span> dict_df_score:  </span><br><span class="line">	adata.obs[trait] = dict_df_score[trait][<span class="string">&quot;raw_score&quot;</span>]  </span><br><span class="line"><span class="keyword">for</span> trait <span class="keyword">in</span> dict_df_score:  </span><br><span class="line">	adata.obs[<span class="string">f&quot;<span class="subst">&#123;trait&#125;</span>_norm&quot;</span>] = dict_df_score[trait][<span class="string">&quot;norm_score&quot;</span>]  </span><br><span class="line">sc.pl.umap(adata,color=dict_df_score.keys(),ncols=<span class="number">1</span>,color_map=<span class="string">&quot;RdBu_r&quot;</span>,save=<span class="string">f&quot;<span class="subst">&#123;sample&#125;</span>_disease.png&quot;</span>)  </span><br><span class="line">df_group = adata.obs  </span><br><span class="line">l = [<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;g&quot;</span>,<span class="string">&quot;h&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;j&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;l&quot;</span>,<span class="string">&quot;m&quot;</span>,<span class="string">&quot;n&quot;</span>,<span class="string">&quot;o&quot;</span>,<span class="string">&quot;p&quot;</span>,<span class="string">&quot;q&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="string">&quot;s&quot;</span>,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;u&quot;</span>,<span class="string">&quot;v&quot;</span>,<span class="string">&quot;w&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;y&quot;</span>,<span class="string">&quot;z&quot;</span>]  </span><br><span class="line">map_list = &#123;&#125;  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(l)):  </span><br><span class="line">	map_list[<span class="built_in">str</span>(i)] = l[i]  </span><br><span class="line">df_group[<span class="string">&quot;group&quot;</span>] = df_group[<span class="string">&quot;leiden&quot;</span>].<span class="built_in">map</span>(map_list)  </span><br><span class="line">df_group.to_csv(<span class="string">f&quot;./output/<span class="subst">&#123;sample&#125;</span>/leiden score.csv&quot;</span>)  </span><br><span class="line">df_gene = scdrs.method.downstream_gene_analysis(adata=adata, df_full_score=dict_df_score[<span class="string">&quot;CHD&quot;</span>])  </span><br><span class="line">df_gene.to_csv(<span class="string">f&quot;./output/<span class="subst">&#123;sample&#125;</span>/key gene.csv&quot;</span>)  </span><br><span class="line">df_group_analysis = scdrs.method.downstream_group_analysis(adata=adata, df_full_score=dict_df_score[<span class="string">&quot;CHD&quot;</span>], group_cols=[<span class="string">&quot;group&quot;</span>])</span><br></pre></td></tr></table></figure>
<h2 id="在命令行中使用scdrs"><a href="#在命令行中使用scdrs" class="headerlink" title="在命令行中使用scdrs"></a>在命令行中使用scdrs</h2><h3 id="计算每个细胞的疾病富集分数"><a href="#计算每个细胞的疾病富集分数" class="headerlink" title="计算每个细胞的疾病富集分数"></a>计算每个细胞的疾病富集分数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Shell</span></span><br><span class="line">scdrs compute-score \  </span><br><span class="line">    --h5ad-file data/expr.h5ad \  </span><br><span class="line">    --h5ad-species human \  </span><br><span class="line">    --gs-file data/processed_geneset.gs \  </span><br><span class="line">    --gs-species human \  </span><br><span class="line">    --cov-file data/cov.tsv \  </span><br><span class="line">    --flag-filter-data True \  </span><br><span class="line">    --flag-raw-count True \  </span><br><span class="line">    --flag-return-ctrl-raw-score False \  </span><br><span class="line">    --flag-return-ctrl-norm-score True \  </span><br><span class="line">    --out-folder data/  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 可视化 python  </span></span><br><span class="line">df_gs.index = [<span class="string">&#x27;CHD&#x27;</span>,<span class="string">&#x27;Height&#x27;</span>]  </span><br><span class="line">dict_score = &#123;  </span><br><span class="line">    trait: pd.read_csv(f<span class="string">&quot;data/&#123;trait&#125;.full_score.gz&quot;</span>, sep=<span class="string">&quot;\t&quot;</span>, index_col=0)  </span><br><span class="line">    <span class="keyword">for</span> trait <span class="keyword">in</span> df_gs.index  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> trait <span class="keyword">in</span> dict_score:  </span><br><span class="line">    adata.obs[trait] = dict_score[trait][<span class="string">&quot;norm_score&quot;</span>]  </span><br><span class="line">  </span><br><span class="line">sc.set_figure_params(figsize=[2.5, 2.5], dpi=150)  </span><br><span class="line">sc.pl.umap(  </span><br><span class="line">    adata,  </span><br><span class="line">    color=dict_score.keys(),  </span><br><span class="line">    ncols=1,  </span><br><span class="line">    color_map=<span class="string">&quot;RdBu_r&quot;</span>,  </span><br><span class="line">    vmin=-5,  </span><br><span class="line">    vmax=5,  </span><br><span class="line">)  </span><br><span class="line">  </span><br><span class="line">sc.pl.umap(  </span><br><span class="line">    adata,  </span><br><span class="line">    color=dict_score.keys(),  </span><br><span class="line">    color_map=<span class="string">&quot;RdBu_r&quot;</span>,  </span><br><span class="line">    vmin=-5,  </span><br><span class="line">    vmax=5,  </span><br><span class="line">    s=20,  </span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;基于单个细胞的疾病富集分数，我们可以充分探索下游分析的方式。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>Zhang, M.J., Hou, K., Dey, K.K. et al. Polygenic enrichment distinguishes disease associations of individual cells in single-cell RNA-seq data. Nat Genet 54, 1572–1580 (2022).<a href="https://doi.org/10.1038/s41588-022-01167-z">DOI</a>.</li>
<li>scDRS的Github项目：<a href="https://github.com/martinjzhang/scDRS">martinjzhang/scDRS</a>。</li>
<li>scDRS的官方文档：<a href="https://martinjzhang.github.io/scDRS/">scDRS</a>。</li>
</ol>
]]></content>
      <categories>
        <category>生物信息学</category>
      </categories>
      <tags>
        <tag>GWAS</tag>
        <tag>生物信息学</tag>
        <tag>单细胞测序</tag>
      </tags>
  </entry>
  <entry>
    <title>scPagwas——整合scRNA和GWAS识别疾病的驱动基因和关键细胞类型</title>
    <url>/2023/08/25/scPagwas%E2%80%94%E2%80%94%E6%95%B4%E5%90%88scRNA%E5%92%8CGWAS%E8%AF%86%E5%88%AB%E7%96%BE%E7%97%85%E7%9A%84%E9%A9%B1%E5%8A%A8%E5%9F%BA%E5%9B%A0%E5%92%8C%E5%85%B3%E9%94%AE%E7%BB%86%E8%83%9E%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>&emsp;&emsp;<strong>scPagwas</strong>的基本思想和CMU张金野教授开发的<strong>scDRS</strong>工具一脉相承。总的来说，该框架可以概述为：  </p>
<ol>
<li>基于基因表达计算单个细胞的通路富集得分（PAS）；  </li>
<li>SNP通过基因和通路联系，得到两者的回归系数，将该回归系数作为权数加权上面得到的PAS，得到一个细胞的gPAS。某种意义上，gPAS是一个细胞疾病相关通路组的富集得分；  </li>
<li>将基因的表达和gPAS做相关性分析，确定最优先的疾病基因。<br>&emsp;&emsp;(1) 到 (3) 的步骤本质上是GWAS映射驱动基因的过程，接着我们根据驱动基因的表达量和驱动基因的权重对细胞的表达量进行加权，从而得到具体的细胞评分——性状相关分数TRS。<br>如果之间关注加权分数的绝对值，那么这个结果很容易受到细胞的检出count数影响，因此作者根据相应的表达值和方差匹配相近的表达基因。从而计算出经验分布，从而进行统计检验。隐含的思想是：疾病特征基因是显著高表达的。</li>
</ol>
<h2 id="GWAS-Summary-Statistics数据的预处理"><a href="#GWAS-Summary-Statistics数据的预处理" class="headerlink" title="GWAS Summary Statistics数据的预处理"></a>GWAS Summary Statistics数据的预处理</h2><p>&emsp;&emsp;<strong>下面的步骤可概述为：首先提取摘要数据中的SNP，然后去计算LD并过滤，最后将过滤后的SNP遴选出来，得到过滤后的GWAS数据。</strong><br>&emsp;&emsp;根据scPagwas和Plink的要求，GWAS文件的以下信息应当被提取，并且要命名为下面的名称：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;chrom&quot;</span>,<span class="string">&quot;pos&quot;</span>,<span class="string">&quot;REF&quot;</span>,<span class="string">&quot;ALT&quot;</span>,<span class="string">&quot;rsid&quot;</span>,<span class="string">&quot;nearest_genes&quot;</span>,<span class="string">&quot;beta&quot;</span>,<span class="string">&quot;se&quot;</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;保存这个文件，比如我们命名为”Disease.txt”：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">write.table(GWAS_raw,file=<span class="string">&quot;./Disease.txt&quot;</span>,row.names=F,quote=F)</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;提取其中的rsid列，用于后续的分析（awk后面的$5代表rsid列的索引）：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> tempfile  &lt;br&gt;awk  <span class="string">&#x27;&#123;print $5 &#125;&#x27;</span> Disease.txt  &gt; ./tempfile/Disease_SNP_list.txt</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;下载并解压plink所需要的文件，如下，这里我们下载东亚人的数据：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://zenodo.org/record/7768714/files/1000G_Phase3_EAS_plinkfiles.tgz?download=1</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;制作bed文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 22)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">plink</span><br><span class="line">--bfile ./1000G_EUR_Phase3_plink/1000G.EAS.QC.<span class="variable">$i</span></span><br><span class="line">--extract ./tempfile/Disease_SNP_list.txt</span><br><span class="line">--noweb --make-bed --out ./tempfile/1000G.EAS.QC.Disease_<span class="variable">$&#123;i&#125;</span>_filtered</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;连锁不平衡过滤<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">seq</span> 1 22)    </span><br><span class="line"><span class="keyword">do</span>   </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span>  </span><br><span class="line">plink   </span><br><span class="line">--bfile ./tempfile/1000G.EAS.QC.Disease_<span class="variable">$&#123;i&#125;</span>_filtered   </span><br><span class="line">--indep-pairwise 50 5 0.8   </span><br><span class="line">--out  ./tempfile/Disease_<span class="variable">$&#123;i&#125;</span>_plink_prune_EAS_filtered_LD0.8  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;结果整合<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ./tempfile/[Disease]*.prune.in &gt; Disease_EAS_LD0.8.prune</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;从GWAS中选择过滤后的SNP<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">library(readr)  </span><br><span class="line">library(dplyr)  </span><br><span class="line">gwas&lt;-read_table(<span class="string">&quot;./Disease.txt&quot;</span>)  </span><br><span class="line">SNP_prune&lt;- read_table(<span class="string">&quot;./tempfile/Disease_EAS_LD0.8.prune&quot;</span>)  </span><br><span class="line">SNP_prune&lt;-SNP_prune[!duplicated(unlist(SNP_prune)),]  </span><br><span class="line">colnames(SNP_prune)&lt;-<span class="string">&quot;rsid&quot;</span>  </span><br><span class="line"><span class="comment">#### Left Join using inner_join function   </span></span><br><span class="line">gwas= gwas %&gt;% inner_join(SNP_prune,by=<span class="string">&quot;rsid&quot;</span>)  </span><br><span class="line"><span class="built_in">print</span>(nrow(gwas))  </span><br><span class="line">write.table(gwas,file=<span class="string">&quot;./Disease_prune_gwas_data.txt&quot;</span>,row.names=F,quote=F)</span><br></pre></td></tr></table></figure></p>
<h2 id="scRNA数据、Pathway数据、注释数据的准备"><a href="#scRNA数据、Pathway数据、注释数据的准备" class="headerlink" title="scRNA数据、Pathway数据、注释数据的准备"></a>scRNA数据、Pathway数据、注释数据的准备</h2><ol>
<li>事实上，scPagwas所需单细胞数据的必要条件是：<strong>（1）单细胞数据已经完成了分群，并且给予了相应的注释；（2）单细胞数据已经被Normalized；</strong></li>
<li>在scPagwas中预置了一个KEGG的通路数据集，所以不需要自己再额外处理；</li>
<li>这一步骤完成的是导入外显子在基因组的范围，相应数据可以从<a href="https://www.gencodegenes.org/human/">GENCODE - Human Release 44 (gencodegenes.org)</a>下载：<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>rtracklayer<span class="punctuation">)</span>  </span><br><span class="line">gtf_df<span class="operator">&lt;-</span> rtracklayer<span class="operator">::</span>import<span class="punctuation">(</span><span class="string">&quot;gencode.v34.annotation.gtf.gz&quot;</span><span class="punctuation">)</span>  </span><br><span class="line">gtf_df <span class="operator">&lt;-</span> as.data.frame<span class="punctuation">(</span>gtf_df<span class="punctuation">)</span>  </span><br><span class="line">gtf_df <span class="operator">&lt;-</span> gtf_df<span class="punctuation">[</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;seqnames&quot;</span><span class="punctuation">,</span><span class="string">&quot;start&quot;</span><span class="punctuation">,</span><span class="string">&quot;end&quot;</span><span class="punctuation">,</span><span class="string">&quot;type&quot;</span><span class="punctuation">,</span><span class="string">&quot;gene_name&quot;</span><span class="punctuation">)</span><span class="punctuation">]</span>  </span><br><span class="line">gtf_df <span class="operator">&lt;-</span> gtf_df<span class="punctuation">[</span>gtf_df<span class="operator">$</span>type<span class="operator">==</span><span class="string">&quot;gene&quot;</span><span class="punctuation">,</span><span class="punctuation">]</span>  </span><br><span class="line">block_annotation<span class="operator">&lt;-</span>gtf_df<span class="punctuation">[</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">]</span>  </span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="标准分析流程"><a href="#标准分析流程" class="headerlink" title="标准分析流程"></a>标准分析流程</h2><h3 id="单细胞数据导入"><a href="#单细胞数据导入" class="headerlink" title="单细胞数据导入"></a>单细胞数据导入</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>scPagwas<span class="punctuation">)</span>  </span><br><span class="line">Pagwas <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="punctuation">)</span>  </span><br><span class="line">Pagwas <span class="operator">&lt;-</span> Single_data_input<span class="punctuation">(</span>  </span><br><span class="line">      Pagwas <span class="operator">=</span> Pagwas<span class="punctuation">,</span>  </span><br><span class="line">      assay <span class="operator">=</span> <span class="string">&quot;RNA&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">      Single_data <span class="operator">=</span> Single_data<span class="punctuation">,</span>  </span><br><span class="line">      Pathway_list <span class="operator">=</span> Genes_by_pathway_kegg  </span><br><span class="line">    <span class="punctuation">)</span>  </span><br><span class="line">Single_data <span class="operator">&lt;-</span> Single_data<span class="punctuation">[</span><span class="punctuation">,</span> </span><br></pre></td></tr></table></figure>
<h3 id="计算每个细胞的通路富集分数"><a href="#计算每个细胞的通路富集分数" class="headerlink" title="计算每个细胞的通路富集分数"></a>计算每个细胞的通路富集分数</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Pagwas <span class="operator">&lt;-</span> Pathway_pcascore_run<span class="punctuation">(</span>  </span><br><span class="line">        Pagwas <span class="operator">=</span> Pagwas<span class="punctuation">,</span>  </span><br><span class="line">        Pathway_list <span class="operator">=</span> Genes_by_pathway_kegg  </span><br><span class="line">      <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="输入GWAS数据"><a href="#输入GWAS数据" class="headerlink" title="输入GWAS数据"></a>输入GWAS数据</h3><p>&emsp;&emsp;注意，事实上，这里的maf不会对结果造成很大影响。<br><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Pagwas <span class="operator">&lt;-</span> GWAS_summary_input<span class="punctuation">(</span>  </span><br><span class="line">    Pagwas <span class="operator">=</span> Pagwas<span class="punctuation">,</span>  </span><br><span class="line">    gwas_data <span class="operator">=</span> gwas_data<span class="punctuation">,</span>  </span><br><span class="line">    maf_filter <span class="operator">=</span> <span class="number">0.1</span>  </span><br><span class="line">  <span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="SNP到基因的映射"><a href="#SNP到基因的映射" class="headerlink" title="SNP到基因的映射"></a>SNP到基因的映射</h3><p>&emsp;&emsp;marg可以设置windowsize，实际上在一些文献中会设计成10k；<br><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Pagwas<span class="operator">$</span>snp_gene_df <span class="operator">&lt;-</span> SnpToGene<span class="punctuation">(</span>  </span><br><span class="line">        gwas_data <span class="operator">=</span> Pagwas<span class="operator">$</span>gwas_data<span class="punctuation">,</span>  </span><br><span class="line">        block_annotation <span class="operator">=</span> block_annotation<span class="punctuation">,</span>  </span><br><span class="line">        marg <span class="operator">=</span> <span class="number">100000</span>  </span><br><span class="line">      <span class="punctuation">)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="SNP到通路的映射"><a href="#SNP到通路的映射" class="headerlink" title="SNP到通路的映射"></a>SNP到通路的映射</h3><p>&emsp;&emsp;这个步骤能够把通路注释到基因组上的区域。<br><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Pagwas <span class="operator">&lt;-</span> Pathway_annotation_input<span class="punctuation">(</span>  </span><br><span class="line">      Pagwas <span class="operator">=</span> Pagwas<span class="punctuation">,</span>  </span><br><span class="line">      block_annotation <span class="operator">=</span> block_annotation  </span><br><span class="line">    <span class="punctuation">)</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;将通路的基因组位置和前面得到的pca矩阵（实质上是通路组）进行联系</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Pagwas <span class="operator">&lt;-</span> Link_pathway_blocks_gwas<span class="punctuation">(</span>  </span><br><span class="line">      Pagwas <span class="operator">=</span> Pagwas<span class="punctuation">,</span>  </span><br><span class="line">      chrom_ld <span class="operator">=</span> chrom_ld<span class="punctuation">,</span>  </span><br><span class="line">      singlecell <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>  </span><br><span class="line">      celltype <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>  </span><br><span class="line">      backingpath<span class="operator">=</span><span class="string">&quot;./temp&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="细胞类型回归"><a href="#细胞类型回归" class="headerlink" title="细胞类型回归"></a>细胞类型回归</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Pagwas<span class="operator">$</span>lm_results <span class="operator">&lt;-</span> Pagwas_perform_regression<span class="punctuation">(</span>  </span><br><span class="line">	Pathway_ld_gwas_data <span class="operator">=</span>Pagwas<span class="operator">$</span>Pathway_ld_gwas_data  </span><br><span class="line"><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
<h3 id="计算gPAS，鉴定风险基因"><a href="#计算gPAS，鉴定风险基因" class="headerlink" title="计算gPAS，鉴定风险基因"></a>计算gPAS，鉴定风险基因</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line">Pagwas <span class="operator">&lt;-</span> scPagwas_perform_score<span class="punctuation">(</span>  </span><br><span class="line">      Pagwas <span class="operator">=</span> Pagwas<span class="punctuation">,</span>  </span><br><span class="line">      remove_outlier <span class="operator">=</span> <span class="literal">TRUE</span>  </span><br><span class="line">    <span class="punctuation">)</span>  </span><br><span class="line">Pagwas<span class="operator">$</span>PCC <span class="operator">&lt;-</span> scPagwas<span class="operator">::</span>scGet_PCC<span class="punctuation">(</span>scPagwas.gPAS.score<span class="operator">=</span>Pagwas<span class="operator">$</span>scPagwas.gPAS.score<span class="punctuation">,</span>  </span><br><span class="line">                                    data_mat<span class="operator">=</span>Pagwas<span class="operator">$</span>data_mat<span class="punctuation">)</span>  </span><br><span class="line">mean_gpas<span class="operator">&lt;-</span>mean<span class="punctuation">(</span>Pagwas<span class="operator">$</span>scPagwas.gPAS.score<span class="punctuation">)</span>  </span><br><span class="line">a1<span class="operator">&lt;-</span>which<span class="punctuation">(</span>Pagwas<span class="operator">$</span>scPagwas.gPAS.score <span class="operator">&gt;=</span> mean_gpas<span class="punctuation">)</span>  </span><br><span class="line">a2<span class="operator">&lt;-</span>which<span class="punctuation">(</span>Pagwas<span class="operator">$</span>scPagwas.gPAS.score <span class="operator">&lt;</span> mean_gpas<span class="punctuation">)</span>  </span><br><span class="line">  </span><br><span class="line">PCC_up <span class="operator">&lt;-</span> scPagwas<span class="operator">::</span>scGet_PCC<span class="punctuation">(</span>scPagwas.gPAS.score<span class="operator">=</span>Pagwas<span class="operator">$</span>scPagwas.gPAS.score<span class="punctuation">[</span>a1<span class="punctuation">]</span><span class="punctuation">,</span>data_mat<span class="operator">=</span>Pagwas<span class="operator">$</span>data_mat<span class="punctuation">[</span><span class="punctuation">,</span>a1<span class="punctuation">]</span><span class="punctuation">)</span>  </span><br><span class="line">PCC1<span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>PCC<span class="operator">=</span>PCC_up<span class="punctuation">,</span>genes<span class="operator">=</span>rownames<span class="punctuation">(</span>PCC_up<span class="punctuation">)</span><span class="punctuation">)</span>  </span><br><span class="line">PCC1<span class="operator">&lt;-</span>PCC1<span class="punctuation">[</span>order<span class="punctuation">(</span>PCC1<span class="operator">$</span>PCC<span class="punctuation">,</span>decreasing<span class="operator">=</span><span class="built_in">T</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="punctuation">]</span>  </span><br><span class="line">PCC<span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>PCC<span class="operator">=</span>PCC1<span class="operator">$</span>PCC<span class="punctuation">)</span>  </span><br><span class="line">rownames<span class="punctuation">(</span>PCC<span class="punctuation">)</span><span class="operator">&lt;-</span>PCC1<span class="operator">$</span>genes  </span><br><span class="line">Pagwas<span class="operator">$</span>PCC_up<span class="operator">&lt;-</span>PCC  </span><br><span class="line">  </span><br><span class="line">PCC_down <span class="operator">&lt;-</span> scPagwas<span class="operator">::</span>scGet_PCC<span class="punctuation">(</span>scPagwas.gPAS.score<span class="operator">=</span>Pagwas<span class="operator">$</span>scPagwas.gPAS.score<span class="punctuation">[</span>a2<span class="punctuation">]</span><span class="punctuation">,</span>data_mat<span class="operator">=</span>Pagwas<span class="operator">$</span>data_mat<span class="punctuation">[</span><span class="punctuation">,</span>a2<span class="punctuation">]</span><span class="punctuation">)</span>  </span><br><span class="line">PCC1<span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>PCC<span class="operator">=</span> <span class="operator">-</span>PCC_down<span class="punctuation">,</span>genes<span class="operator">=</span>rownames<span class="punctuation">(</span>PCC_down<span class="punctuation">)</span><span class="punctuation">)</span>  </span><br><span class="line">PCC1<span class="operator">&lt;-</span>PCC1<span class="punctuation">[</span>order<span class="punctuation">(</span>PCC1<span class="operator">$</span>PCC<span class="punctuation">,</span>decreasing<span class="operator">=</span><span class="built_in">F</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="punctuation">]</span>  </span><br><span class="line">PCC<span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>PCC<span class="operator">=</span>PCC1<span class="operator">$</span>PCC<span class="punctuation">)</span>  </span><br><span class="line">rownames<span class="punctuation">(</span>PCC<span class="punctuation">)</span><span class="operator">&lt;-</span>PCC1<span class="operator">$</span>genes  </span><br><span class="line">Pagwas<span class="operator">$</span>PCC_down<span class="operator">&lt;-</span>PCC</span><br></pre></td></tr></table></figure>
<h3 id="计算TRS"><a href="#计算TRS" class="headerlink" title="计算TRS"></a>计算TRS</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Obtain the top 500 genes with the highest PCC.  </span></span><br><span class="line">n_topgenes<span class="operator">=</span><span class="number">500</span>  </span><br><span class="line">scPagwas_topgenes <span class="operator">&lt;-</span> rownames<span class="punctuation">(</span>Pagwas<span class="operator">$</span>PCC<span class="punctuation">)</span><span class="punctuation">[</span>order<span class="punctuation">(</span>Pagwas<span class="operator">$</span>PCC<span class="punctuation">,</span> decreasing <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span>n_topgenes<span class="punctuation">]</span><span class="punctuation">]</span>  </span><br><span class="line">scPagwas_upgenes <span class="operator">&lt;-</span> rownames<span class="punctuation">(</span>Pagwas<span class="operator">$</span>PCC_up<span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span>n_topgenes<span class="punctuation">]</span>  </span><br><span class="line">scPagwas_downgenes <span class="operator">&lt;-</span> rownames<span class="punctuation">(</span>Pagwas<span class="operator">$</span>PCC_down<span class="punctuation">)</span><span class="punctuation">[</span><span class="number">1</span><span class="operator">:</span>n_topgenes<span class="punctuation">]</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#Single_data refers to the single-cell data initially inputted.  </span></span><br><span class="line">Single_data <span class="operator">&lt;-</span> Seurat<span class="operator">::</span>AddModuleScore<span class="punctuation">(</span>Single_data<span class="punctuation">,</span> assay <span class="operator">=</span> <span class="string">&quot;RNA&quot;</span><span class="punctuation">,</span> <span class="built_in">list</span><span class="punctuation">(</span>scPagwas_topgenes<span class="punctuation">,</span>scPagwas_upgenes<span class="punctuation">,</span>scPagwas_downgenes<span class="punctuation">)</span><span class="punctuation">,</span> name <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;scPagwas.TRS.Score&quot;</span><span class="punctuation">,</span><span class="string">&quot;scPagwas.upTRS.Score&quot;</span><span class="punctuation">,</span><span class="string">&quot;scPagwas.downTRS.Score&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#Calculate the p-values for scPagwas.TRS.Score of single cells after background correction.  </span></span><br><span class="line">correct_pdf<span class="operator">&lt;-</span>Get_CorrectBg_p<span class="punctuation">(</span>Single_data<span class="operator">=</span>Single_data<span class="punctuation">,</span>  </span><br><span class="line">                             scPagwas.TRS.Score<span class="operator">=</span>Single_data<span class="operator">$</span>scPagwas.TRS.Score1<span class="punctuation">,</span>  </span><br><span class="line">                             iters_singlecell<span class="operator">=</span><span class="number">100</span><span class="punctuation">,</span>  </span><br><span class="line">                             n_topgenes<span class="operator">=</span><span class="number">1000</span><span class="punctuation">,</span>  </span><br><span class="line">                             scPagwas_topgenes<span class="operator">=</span>scPagwas_topgenes<span class="punctuation">)</span>  </span><br><span class="line">Pagwas<span class="operator">$</span>Random_Correct_BG_pdf <span class="operator">&lt;-</span> correct_pdf  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#Merge the p-values of cells belonging to the same cell type into a single p-value for each cell type.  </span></span><br><span class="line">Pagwas<span class="operator">$</span>Merged_celltype_pvalue<span class="operator">&lt;-</span>Merge_celltype_p<span class="punctuation">(</span>single_p<span class="operator">=</span>correct_pdf<span class="operator">$</span>pooled_p<span class="punctuation">,</span>celltype<span class="operator">=</span>Pagwas<span class="operator">$</span>Celltype_anno<span class="operator">$</span>annotation<span class="punctuation">)</span>  </span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cell.com/cell-genomics/fulltext/S2666-979X(23">Polygenic regression uncovers trait-relevant cellular contexts through pathway activation transformation of single-cell RNA sequencing data: Cell Genomics</a>00180-5)</p>
]]></content>
      <categories>
        <category>生物信息学</category>
      </categories>
      <tags>
        <tag>GWAS</tag>
        <tag>生物信息学</tag>
        <tag>单细胞测序</tag>
      </tags>
  </entry>
  <entry>
    <title>一起来感受数据之美吧！</title>
    <url>/2023/10/04/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%84%9F%E5%8F%97%E6%95%B0%E6%8D%AE%E4%B9%8B%E7%BE%8E%E5%90%A7%EF%BC%81/</url>
    <content><![CDATA[<h2 id="资源记录"><a href="#资源记录" class="headerlink" title="资源记录"></a>资源记录</h2><ol>
<li><a href="https://bookdown.org/wangminjie/R4DS/">前言 | 数据科学中的 R 语言 (bookdown.org)</a>（四川师范大学研究生公选课《数据科学中的R语言》的课程内容，其中也会涉及简单的数据科学原理）；</li>
<li><a href="https://www.bioinfo-scrounger.com/">KeepNotes blog (bioinfo-scrounger.com)</a>（一些R语言和统计问题拾贝）；</li>
<li><a href="https://cosx.org/">统计之都 (cosx.org)</a>（中文统计学论坛，会定期发表文章，介绍最新的R包，统计学模型和访谈）；</li>
<li><a href="https://csdiy.wiki/">CS自学指南 (csdiy.wiki)</a>（计算机科学自学指南，其中包括了一个计算机专业学生的知识体系）；</li>
<li><a href="https://www.writebug.com/">WRITE-BUG数字空间 - 新一代一站式团队协作知识库 (writebug.com)</a>（Writebug有很多高质量的，类似于微信公众号的文章）；</li>
<li><a href="https://book.ncrnalab.org/teaching/">Bioinformatics Tutorial - Bioinformatics Tutorial (ncrnalab.org)</a> （一个以应用为导向的生物信息学学习站）；</li>
<li><a href="https://www.cnblogs.com/leezx/">Life·Intelligence - 博客园 (cnblogs.com)</a>）（博主主要关注生物科学、单细胞测序的知识）；</li>
<li><a href="https://ailearning.apachecn.org/">【布客】AI Learning (apachecn.org)</a>（AI学习的一站式，偏应用）；</li>
<li><a href="https://forrestgump618.github.io/2023/08/12/%E5%8D%95%E7%BB%86%E8%83%9E%E6%B5%8B%E5%BA%8F%E6%95%99%E7%A8%8B%E8%B5%84%E6%BA%90%E8%81%9A%E5%90%88/">单细胞测序教程资源聚合 | 一个夏天的年少 (forrestgump618.github.io)</a> （单细胞测序教程资源整合）；<br> 此外，多去关注Github上有趣的教程和项目。<br> 书本推荐：</li>
<li>《高等数学》（同济）；《线性代数》（上交）；《概率论和数理统计》（浙大）；</li>
<li>《生物统计学基础》（Fundamentals of Biostatistics；Bernard Rosner）；《流行病学》（人民卫生出版社）；</li>
<li>《鸢尾花书：从加减乘除到机器学习》（<a href="https://github.com/Visualize-ML">Visualize-ML (Iris Series: Visualize Math – From Arithmetic Basics to Machine Learning) · GitHub</a>）；</li>
<li>《R语言编程—基于tidyverse》；</li>
<li>《遗传学基础》（ <a href="https://book.douban.com/search/William%20S.Klug">William S.Klug</a> / <a href="https://book.douban.com/search/Michael%20R.Cummings">Michael R.Cummings</a> / <a href="https://book.douban.com/search/Charlotte%20A.Spencer">Charlotte A.Spencer</a> / <a href="https://book.douban.com/search/Michael%20A.Palladino">Michael A.Palladino</a>）。</li>
</ol>
<h2 id="一些牢骚"><a href="#一些牢骚" class="headerlink" title="一些牢骚"></a>一些牢骚</h2><p>&emsp;&emsp;大一，医用物理学的最后一章——混沌理论，采用数学的方法建模复杂动力学系统的运行规律，并提出了一点轻微的初值改变就可以让整个系统天翻地覆，即著名的蝴蝶定律。<br>&emsp;&emsp;当然，这并不意味着倘若那只蝴蝶扇动翅膀，就必然会引起飓风；但若我们逮到所有的蝴蝶，那么飓风可以预测。这强烈提示人们一种认知观点，复杂的现象背后可以拆解为简单的论断；基于底层法则，自然界得以混沌。<br>&emsp;&emsp;生命是自然界最复杂的现象，就在您读这句话的一刹那，组成我们身体的亿万细胞正发生着无法计数的生命事件，伴随着无法计数的化学物质数量和性质的变化。医学发展的某些部分，尤其是中医学，习惯用系统论的思维去认识生命活动，化繁为简，这方便了知识的理解，也让机械零碎的医学知识得到整合，但其似乎无法回答最根本的问题——生命究竟是什么？<br>&emsp;&emsp;还原论把知识构建在底层逻辑上，如薛定谔尝试用基本的物理学去解释生命发生。但还原论有时会陷入机械唯物论的窠臼。<br>&emsp;&emsp;人类的智慧在于突破概念，不必困惑在还原论和系统论的是非之中。认识世界的方向一定是刨根问底，寻根思因的；在其中，系统论帮助我们更进一步了解可能的逻辑……但这是符合人类思维的逻辑，人类是否能认知最后的核心还不得而知。<br>&emsp;&emsp;对于生命而言，其现象本身是基于自然界的物理规律。故探根问底，也会在我们能理解的知识结构内。<br>&emsp;&emsp;如何寻找生命科学的原子命题？我想，就不能完全依靠传统生命科学逐个知识的积累，而应该充分利用生物数据去解析其背后的模式。<br>&emsp;&emsp;感谢大一时的计算机课，感谢大一时候用免疫学逻辑启蒙我的刘文涛教授，给我打开一扇理解世界的门。<br>&emsp;&emsp;看似的有序中，人们会发现无序。而我们的梦想就是，发现无序背后更深刻的有序，那么我们就有可能进一步探索用现有范式所不能描述、解释或预测的现象。</p>
<h2 id="学习体会"><a href="#学习体会" class="headerlink" title="学习体会"></a>学习体会</h2><p>&emsp;&emsp;陷于晋升、升学的要求，互联网上主要是快餐式的学习，一些便捷的工具也层出不穷。<br>&emsp;&emsp;基于应用的学习并不困难，许多优秀的公众号和博客，以及Github上有丰富的资源。但是大家未必有这个意识，从而形成所谓壁垒，构建了虚伪的不可替代性，而实际上人人都应该能获取这样的知识。<br>&emsp;&emsp;但，如果有兴趣，我们可以尝试啃一啃硬骨头，理解其基本原理，掌握基本的思维方法，从中认识到人类思维探索的规律。<br>&emsp;&emsp;我的学习路径，是从应用式的学习开始：<br>（1）统计学理论（掌握统计学的基本思维模式，所以了解知识的来历很重要）：生物统计学基础（Fundamentals of Biostatistics；Bernard Rosner）；<br>（2）流行病学理论（掌握流行病学的基本思想，我觉得流行病学最核心观点是比较，而由于主要研究样本，所以如何妥善解决样本相关问题占据了流行病学中大部分内容（可以概括为代表性和可比性）。重点是要能够设计合理的研究框架）：流行病学（人民卫生出版社；沈洪兵）；<br>（3）公众号（主要的反而不是里面的代码，而是推送的文章，文章里面会采用各种统计模型；善于用微信搜索东西，但是……看多了也会信息爆炸）：生信技能树（转录组学）；灵活胖子的科研进步之路（临床统计等）；<br>（4）编程：Python；R语言（mlr3包弥补了R语言机器学习较弱的历史）：推荐《R语言编程—基于tidyverse》；张敬信；C++（Python和R处理矩阵读写非常耗时间，C++可以有效解决这一问题）；Linux（linux学习后，对于计算机会用得更加得心应手，习惯用命令行解决问题后效率会大大提高）：系统架构的原理，基本命令的掌握。<br>（5）其他人的文章；<br>（6）基础数学（和几个高中同学一直保持联系，感受到数学系的同学的确是有一种独特的思维特性去思考问题的，而且我这个时候也遇上了数学基础不够深入理解原理的瓶颈）：《数学分析》（主要是基本的微积分，多元函数看一部分；用《高等数学》（同济）或者《数学分析》（复旦）都可以）；《线性代数》（对于处理生物数据非常重要！但医学生往往不深入学习这个。理解线性代数的基本思想，推荐上海交通大学的《线性代数》）；《概率论和数理统计》（生物统计学那本书里面只会关注基本的统计检验，对于不同的统计学学派，原理不会过多介绍。但概率论和数理统计中大量的数学推导就要求有数学分析的基础）。<br>&emsp;&emsp;其他：<br>&emsp;&emsp;对于基础数学部分，推荐《鸢尾花书：从加减乘除到机器学习》。这套书在Github有开源版本，里面丰富的可视化对于理解线性代数相关知识非常直观。<br>&emsp;&emsp;机器学习部分推荐从《统计学习方法》入门，先修分析学、线性代数和概率论。周志华的《机器学习》实际上数学理论比《统计学习方法》低一点，能够构建对机器学习是什么的认知。<br>&emsp;&emsp;上述理论部分所蕴含的思维方法对于认识世界是一种角度，同时上述的技术部分也的确在方便我们生活，发散我们思维，所以感觉是充实的。<br>&emsp;&emsp;期间，可能需要对遗传学、尤其是基因组学数据有深入了解。可以去啃一下国外的《遗传学基础》（可以当作工具书）。<br>&emsp;&emsp;有时候会有点间断，这个时候会想起已故南大计算机教授徐家福教授八十多岁跨界学习量子力学的实例，共勉~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>统计学</tag>
        <tag>交叉学科</tag>
      </tags>
  </entry>
  <entry>
    <title>单细胞转录组分析实战（一）：数据采集</title>
    <url>/2023/02/17/%E5%8D%95%E7%BB%86%E8%83%9E%E8%BD%AC%E5%BD%95%E7%BB%84%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/</url>
    <content><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>&emsp;&emsp;本系列将基于张泽民团队发表的TNBC免疫图谱进行挖掘（<a href="https://www.cell.com/cancer-cell/fulltext/S1535-6108(21">Single-cell analyses reveal key immune cell subsets associated with response to PD-L1 blockade in triple-negative breast cancer: Cancer Cell</a>00499-2)），旨在探索原发灶和转移灶免疫微环境的差异及其原因。<br>&emsp;&emsp;准确严谨的采集和清洗数据是单细胞分析的开始，数据本身的质量和采集过程的规范程度决定了研究结果的可靠性。</p>
<h2 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h2><h3 id="患者来源"><a href="#患者来源" class="headerlink" title="患者来源"></a>患者来源</h3><p>&emsp;&emsp;国家癌症中心开发的DTHealth TrakCare系统中记录了患者信息，纳入本研究的22名患者满足：（1）组织学确诊晚期TNBC；（2）既往没有化疗、靶向及免疫等全身治疗；（3）研究中接受紫杉醇单药治疗或紫杉醇加阿替利珠单抗治疗。</p>
<h3 id="患者信息"><a href="#患者信息" class="headerlink" title="患者信息"></a>患者信息</h3><ol>
<li>本研究所有患者均被诊断为晚期TNBC，大多数患者患有转移性疾病；</li>
<li>事实上，一些患者是接受新辅助治疗的局部晚期患者；</li>
<li>患者为女性，年龄在32-64岁之间，中位值为49岁；</li>
</ol>
<p><img src="/2023/02/17/%E5%8D%95%E7%BB%86%E8%83%9E%E8%BD%AC%E5%BD%95%E7%BB%84%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/1.jpg" alt="临床信息"></p>
<h3 id="样本收集、文库制备和测序"><a href="#样本收集、文库制备和测序" class="headerlink" title="样本收集、文库制备和测序"></a>样本收集、文库制备和测序</h3><p>&emsp;&emsp;研究使用16针吸穿刺取乳腺、胸壁肿瘤样本；18号针取淋巴结、肝转移灶样本。测序仪器是10x Genomics公司的HiSeq X Ten，平台为<a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GPL20795">GPL20795</a>。DNA片段被打碎为150bp，进行双端测序。</p>
<h2 id="单细胞转录组数据处理"><a href="#单细胞转录组数据处理" class="headerlink" title="单细胞转录组数据处理"></a>单细胞转录组数据处理</h2><p>&emsp;&emsp;10x Genomics公司提供的Cell Ranger（V 3.0.1）用于汇总原始数据，过滤低质量读段，将reads与人类参考基因组（GRCh38）比对，分配细胞Barcode，并生成UMI矩阵。值得注意的是，对于10x Genomics公司的测序，由于UMI的存在，使用Raw Count即可反映真实的基因表达，不需要使用标准化方法进行基因定量（<a href="https://forrestgump618.github.io/2024/02/16/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%9F%BA%E5%9B%A0%E5%AE%9A%E9%87%8F/">生物信息学笔记（三）：基因定量</a>）。但注意，这里所谓“真实的基因表达”反映的是测序过程中的真实值，即不必考虑测序深度和转录本长度的值；而单细胞测序中，由于转录本的低捕获率，我们假设合格细胞基因表达总量应该类似，所以还要进行标准化排除不同细胞测序质量的差异。<br>&emsp;&emsp;原文使用Scanpy进行下游分析，质控步骤包括：</p>
<ol>
<li>过滤在少于10个细胞中表达的基因；</li>
<li>过滤少于200个基因的细胞中检测到的基因；</li>
<li>保留了600-120,000个UMIs、400-8,000个基因和小于10%线粒体基因计数的高质量细胞；</li>
<li>将Scrublet应用于每个测序文库，以去除预期的双峰率为6%的潜在双峰，并滤除doubletScore大于90%分位数的细胞；</li>
</ol>
<p>&emsp;&emsp;接着，我们进行标准化操作：</p>
<ol>
<li>标准化每个细胞的总计数（库大小）：这一步是为了消除不同细胞间样本量的差异。库大小通常是指一个细胞中检测到的总UMI数。通过将每个细胞的UMI计数除以该细胞的总UMI计数，可以确保数据在不同细胞间是可比的。</li>
<li>乘以1e6：这一步是为了放大数据，使其更易于处理。通常在生物信息学中，进行这样的转换是为了避免处理极小的数字。</li>
<li>对数据进行对数变换：最后，对标准化后的数据进行对数变换是为了减少数据中极端值的影响，使数据的分布更接近正态分布。这通常有助于后续的统计分析和可视化。</li>
</ol>
<p>&emsp;&emsp;前面的步骤完成了单细胞转录组数据的质控和标准化，下面进行矩阵降维，进一步排除无关变量的影响，同时压缩分析规模：</p>
<ol>
<li>选择前4000个可变基因，排除大部分背景基因的影响；</li>
<li>从标准化表达矩阵中去除总计数、线粒体基因计数和热休克蛋白（HSP）相关基因计数的变异，以避免偏差；</li>
<li>主成分分析，把4000个可变基因降为50个主成分；</li>
<li>由此，我们得到了50×细胞数的矩阵，即对于每个细胞有50个变量，使用前2个或者3个主成分进行可视化，通过标注不同样本，发现潜在的批次效应，并通过相应的算法（在R中可以通过Harmony）去除；</li>
<li>由此，我们尽可能避免了因非研究变量因素导致的系统误差，得到新的标准化矩阵。</li>
</ol>
<p>&emsp;&emsp;最后，Leiden算法寻找细胞簇和分群，UMAP和TSNE进行作图，推荐使用COSG确定Marker。</p>
]]></content>
      <categories>
        <category>生物信息学</category>
      </categories>
      <tags>
        <tag>单细胞测序</tag>
        <tag>免疫</tag>
        <tag>肿瘤</tag>
      </tags>
  </entry>
  <entry>
    <title>孟德尔随机化标准流程代码示例</title>
    <url>/2024/02/05/%E5%AD%9F%E5%BE%B7%E5%B0%94%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%A0%87%E5%87%86%E6%B5%81%E7%A8%8B%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment">####TSMR####</span></span><br><span class="line">library<span class="punctuation">(</span>TwoSampleMR<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>MRPRESSO<span class="punctuation">)</span></span><br><span class="line"><span class="comment">####NAFLD - COVID 19####</span></span><br><span class="line"><span class="comment">####RCT####</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####NAFLD_exposure####</span></span><br><span class="line">exposure_dat<span class="operator">&lt;-</span>read_exposure_data<span class="punctuation">(</span>filename <span class="operator">=</span> <span class="string">&quot;./NAFLD.txt&quot;</span><span class="punctuation">,</span>sep<span class="operator">=</span><span class="string">&quot;\t&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                 snp_col <span class="operator">=</span> <span class="string">&quot;rsids&quot;</span><span class="punctuation">,</span>effect_allele_col <span class="operator">=</span> <span class="string">&quot;alt&quot;</span><span class="punctuation">,</span>other_allele_col <span class="operator">=</span> <span class="string">&quot;ref&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                 beta_col <span class="operator">=</span> <span class="string">&quot;beta&quot;</span><span class="punctuation">,</span>se_col <span class="operator">=</span> <span class="string">&quot;sebeta&quot;</span><span class="punctuation">,</span>pval_col <span class="operator">=</span> <span class="string">&quot;pval&quot;</span><span class="punctuation">,</span>eaf_col <span class="operator">=</span> <span class="string">&quot;af_alt&quot;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">##看目录下的文件进行对应，如果读一个完整的文件，需要进行P值筛选</span></span><br><span class="line"></span><br><span class="line">exposure_dat<span class="operator">$</span>phenotype<span class="operator">&lt;-</span><span class="string">&quot;NAFLD&quot;</span></span><br><span class="line"><span class="comment">##命名性状，方便结果输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#### kb=10000;r2=0.001;</span></span><br><span class="line"><span class="comment">#### kb=500;r2=0.1.</span></span><br><span class="line">exposure_dat<span class="operator">&lt;-</span>clump_data<span class="punctuation">(</span>exposure_dat<span class="punctuation">)</span></span><br><span class="line"><span class="comment">##连锁不平衡去除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####COVID19_OUTCOME####</span></span><br><span class="line">outcome_dat<span class="operator">&lt;-</span>extract_outcome_data<span class="punctuation">(</span>outcomes <span class="operator">=</span> <span class="string">&quot;ebi-a-GCST011081&quot;</span><span class="punctuation">,</span>snps <span class="operator">=</span> exposure_dat<span class="operator">$</span>SNP<span class="punctuation">)</span></span><br><span class="line"><span class="comment">##在线读取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####Harmonization####</span></span><br><span class="line">dat<span class="operator">&lt;-</span>harmonise_data<span class="punctuation">(</span>exposure_dat <span class="operator">=</span> exposure_dat</span><br><span class="line">                    <span class="punctuation">,</span>outcome_dat <span class="operator">=</span> outcome_dat<span class="punctuation">,</span></span><br><span class="line">                    action <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">##dat协调，去除回文序列，错配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####F&gt;10####</span></span><br><span class="line">dat<span class="operator">$</span><span class="built_in">F</span><span class="operator">&lt;-</span><span class="punctuation">(</span>dat<span class="operator">$</span>beta.exposure<span class="operator">/</span>dat<span class="operator">$</span>se.exposure<span class="punctuation">)</span><span class="operator">**</span><span class="number">2</span></span><br><span class="line">dat<span class="operator">&lt;-</span>subset<span class="punctuation">(</span>dat<span class="punctuation">,</span><span class="built_in">F</span><span class="operator">&gt;</span><span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">mr_result <span class="operator">&lt;-</span> mr<span class="punctuation">(</span>dat<span class="punctuation">)</span></span><br><span class="line"><span class="comment">##F值-遗传力计算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####Sensitivity,p&gt;0.05####</span></span><br><span class="line">het<span class="operator">&lt;-</span>mr_heterogeneity<span class="punctuation">(</span>dat<span class="punctuation">)</span></span><br><span class="line">ple<span class="operator">&lt;-</span>mr_pleiotropy_test<span class="punctuation">(</span>dat<span class="punctuation">)</span></span><br><span class="line"><span class="comment">###sNP pleiotropy: Phennoscaner; MR-PRESSO</span></span><br><span class="line">mr_presso<span class="punctuation">(</span>data <span class="operator">=</span> dat<span class="punctuation">,</span>BetaOutcome <span class="operator">=</span> <span class="string">&quot;beta.outcome&quot;</span><span class="punctuation">,</span>BetaExposure <span class="operator">=</span> <span class="string">&quot;beta.exposure&quot;</span><span class="punctuation">,</span>SdOutcome <span class="operator">=</span> <span class="string">&quot;se.outcome&quot;</span><span class="punctuation">,</span>SdExposure <span class="operator">=</span> <span class="string">&quot;se.exposure&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####Graph####</span></span><br><span class="line">mr_funnel_plot<span class="punctuation">(</span>singlesnp_results <span class="operator">=</span> mr_singlesnp<span class="punctuation">(</span>dat<span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">###het p</span></span><br><span class="line">mr_forest_plot<span class="punctuation">(</span>mr_singlesnp<span class="punctuation">(</span>dat<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">mr_scatter_plot<span class="punctuation">(</span>mr_results <span class="operator">=</span> mr_result<span class="punctuation">,</span>dat <span class="operator">=</span> dat<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>流行病学</category>
      </categories>
      <tags>
        <tag>GWAS</tag>
        <tag>统计学</tag>
        <tag>孟德尔随机化</tag>
        <tag>流行病学</tag>
      </tags>
  </entry>
  <entry>
    <title>单细胞测序教程资源聚合</title>
    <url>/2023/08/12/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E6%95%99%E7%A8%8B%E5%92%8C%E8%B5%84%E6%BA%90%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h4 id="转录组学"><a href="#转录组学" class="headerlink" title="转录组学"></a>转录组学</h4><ol>
<li>单细胞测序-最佳的分析Pipeline <a href="https://single-cell-tutorial.readthedocs.io/zh/latest/">单细胞测序-最佳的分析Pipeline</a> ：Zehua Zeng等为主要作者，包括详细的原理和处理流程（Python）；其中重点介绍了Omicverse的使用； </li>
<li>哈佛大学单细胞中文笔记：<a href="https://zhuanlan.zhihu.com/p/209018565">哈佛大学单细胞中文笔记</a> 陈同博士撰写。主要包括原理和Seurat的使用。<a href="https://hbctraining.github.io/main">原版教程</a>；</li>
<li>RNA-SEQ BLOG：最新的RNA测序资讯：<a href="https://www.rna-seqblog.com/">RNA-Seq Blog</a></li>
</ol>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><h4 id="肿瘤生信"><a href="#肿瘤生信" class="headerlink" title="肿瘤生信"></a>肿瘤生信</h4><ol>
<li>GEPIA2：GEPIA2是一个无代码可视化平台，其数据来源于TCGA和GTEx数据库，用户可以自由探索指定基因的在肿瘤组织中的表达情况以及和预后的关系。<a href="http://gepia2.cancer-pku.cn/">GEPIA2</a></li>
<li>Prognoscan：Prognoscan整合了2010年以前GEO上Microarray和相应临床信息，可以探索制定基因自不同数据集中和预后的关系。<a href="http://dna00.bio.kyutech.ac.jp/PrognoScan/">PrognoScan</a></li>
<li>TIMER：TIMER用于分析不同癌症类型的免疫浸润（数据来自于TCGA）。<a href="http://timer.cistrome.org/">TIMER2.0</a></li>
</ol>
<h4 id="GWAS"><a href="#GWAS" class="headerlink" title="GWAS"></a>GWAS</h4><ol>
<li>IEU OPEN GWAS：包含42,484 个GWAS摘要数据集的214,725,223,303 个遗传关联的数据库。<a href="https://gwas.mrcieu.ac.uk/">IEU OpenGWAS</a></li>
<li>PheWeb：包含Biobank Japan，以及UKB等欧洲样本的GWAS结果。<a href="https://pheweb.jp/downloads">PheWeb</a></li>
<li>GWAS catalog：内容较全，网页比较慢，建议使用特殊方式访问。<a href="https://www.ebi.ac.uk/gwas/downloads/summary-statistics">GWAS catalog</a>:</li>
<li>EGG：早期生长联盟数据，包含出生体重，出生头围等。<a href="http://egg-consortium.org/index.html">EGG</a></li>
<li>CKDGEN：包含慢性肾病、MA、eGFR等。<a href="http://ckdgen.imbi.uni-freiburg.de/?tdsourcetag=s_pctim_aiomsg">CKDGEN</a></li>
<li>GLGC：血脂GWAS数据库。<a href="http://csg.sph.umich.edu/willer/public/glgc-lipids2021/">GLGC</a></li>
<li>PGC：精神病学基因组学联盟。<a href="https://www.med.unc.edu/pgc/results-and-downloads/downloads">PGC</a></li>
<li>GEFOS：骨质疏松联盟。<a href="http://www.gefos.org/">GEFOS</a></li>
<li>DIAGRAM：二型糖尿病数据库。<a href="http://diagram-consortium.org/downloads.html">DIAGRAM</a>: </li>
<li>代谢组学数据库：<a href="http://www.metabolomix.com/list-of-all-published-gwas-with-metabolomics/">A Table of all published GWAS with metabolomics</a></li>
</ol>
]]></content>
      <categories>
        <category>生物信息学</category>
      </categories>
      <tags>
        <tag>生物信息学</tag>
        <tag>单细胞测序</tag>
      </tags>
  </entry>
  <entry>
    <title>生物信息学笔记（一）：转录组测序技术</title>
    <url>/2024/02/05/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BD%AC%E5%BD%95%E7%BB%84%E6%B5%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&emsp;&emsp;<strong>转录组</strong>是特定组织或细胞在某一发育阶段或功能状态下转录出来的所有RNA的集合，包括编码蛋白质的mRNA和非编码RNA（non coding RNA, ncRNA）。<strong>转录组测序</strong>是指利用第二代高通量测序技术进行<strong>cDNA</strong>测序，全面快速地获取某一物种特定器官或组织在某一状态下的几乎所有转录本。</p>
<p>&emsp;&emsp;转录组分析的主要目标是：</p>
<ol>
<li>对所有的转录产物进行分类；</li>
<li>确定基因的转录结构，如其起始位点，5′和3′末端，剪接模式和其他转录后修饰；</li>
<li>量化各转录本在发育过程中和不同条件下(如生理/病理)表达水平的变化。</li>
</ol>
<p>&emsp;&emsp;在更早的科学研究中，人们主要利用芯片杂交平台，预先设计基因探针从而完成测序。下一代测序（Next generation sequencing, NGS）的发展变革了测序方法，实现了单核苷酸水平的精准识别，人们不必预先设计探针，并能探索基因精细、稀有的转录结构。</p>
<h2 id="基因芯片"><a href="#基因芯片" class="headerlink" title="基因芯片"></a>基因芯片</h2><p>&emsp;&emsp;虽然本文主要介绍RNA-seq这一技术，但实际上RNA-seq的目的和最终获得的数据格式与基因芯片有着相似之处，即都是以数据矩阵的形式呈现。因此，在介绍RNA-seq之前，我们有必要先了解一下基因芯片。</p>
<ul>
<li><strong>原理</strong>：基于分子杂交技术，基因芯片主要依赖于印刷有荧光标记的探针来实现。例如，基因组芯片是一种常见的基因芯片类型，它集成了高密度的探针，具有高达几个碱基对到100个碱基对的分辨率。通过将样品与这些探针进行杂交，并使用荧光染料进行显色，可以揭示转录组的信息。这一原理与血浆cfDNA的测定方法非常相似（即使用<strong>分光光度仪</strong>）。</li>
<li><strong>流程</strong>：<ol>
<li>标记mRNA或cDNA文库；</li>
<li>与设计好的探针相杂交；</li>
<li>洗脱之后，只有与探针特异性结合的cDNA得以保留；</li>
<li>成像系统拍照捕捉信息；</li>
</ol>
</li>
<li><strong>原始数据</strong>：由仪器对杂交结果照像生成的图片，保存格式为CEL格式；</li>
<li><strong>参考数据</strong>：基因芯片探针排布的信息，保存为CDF格式；</li>
<li><strong>优点</strong>：高度集成，易于应用，成本低；</li>
<li><strong>缺点</strong>：  <ol>
<li>高度地依赖已知信息；  </li>
<li>高背景噪音，非特异杂交会带来的<strong>无法分辨弱信号</strong>和<strong>信号过饱和</strong>的问题；  </li>
<li>在不同样品的比较当中，甚至在同一芯片内部，都存在杂交不均匀带来的各种问题，需要<strong>标准化</strong>等统计学方法来对结果校正；  </li>
<li>无法对可变剪接进行分析。<br>&emsp;&emsp;数据清洗和标准化我们会在后续章节进行阐述。</li>
</ol>
</li>
</ul>
<h2 id="NGS"><a href="#NGS" class="headerlink" title="NGS"></a>NGS</h2><p>&emsp;&emsp;NGS是一种高通量、高效率的基因组测序技术，它在基因组学和生物学研究中具有广泛的应用。下一代测序相对于传统的Sanger测序方法，具有更快速、更经济、更高通量的特点。</p>
<ul>
<li><strong>原理</strong>：将待测DNA样本分离成小片段，并使用特定的方法进行扩增、捕获和测序。然后在高通量平台上进行并行测序，生成大量的序列片段。这些片段随后通过计算和分析，可以重构原始的DNA序列信息。</li>
<li><strong>步骤</strong>：<ol>
<li>分离样本中的RNA，反转录为DNA；</li>
<li>样品制备：DNA样本需要被处理和准备成适合测序的库。这包括DNA提取、片段化和标记等步骤。</li>
<li>文库构建：将片段化的DNA样本连接到适当的测序适配器上，形成文库。适配器中包含了特定的序列，用于后续的扩增和测序。</li>
<li>扩增：将文库中的DNA片段进行扩增，通常采用PCR（聚合酶链式反应）方法。扩增后的文库可以包含成百上千万个DNA片段的复制。</li>
<li>测序：将扩增的文库加载到下一代测序仪中，进行高通量的并行测序。不同的下一代测序技术会使用不同的原理和方法，如Illumina的测序-by-synthesis技术、Ion Torrent的测序-by-detection技术等。</li>
<li>数据分析：通过计算和分析，将测序仪输出的原始数据转化为DNA序列信息。这包括图像处理、碱基识别、序列拼接、质量控制和变异检测等步骤。<img src="/2024/02/05/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BD%AC%E5%BD%95%E7%BB%84%E6%B5%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/1.png" alt></li>
</ol>
</li>
<li><strong>步骤（细节）</strong> ：<ol>
<li>目前很多PCR使用的高保真Pfu聚合酶产生的片段末端是平齐的（即没有不配对的碱基）；鸟枪法产生的片段则是随机断裂，其末端可能是平齐的也可能是不平的，那么我们首先可以使用Taq聚合酶补齐不平的末端，在DNA双链的末端（3‘ 端），我们添加突出的A碱基，以为连接接头做准备（Adaptor）；<img src="/2024/02/05/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BD%AC%E5%BD%95%E7%BB%84%E6%B5%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/2.png" alt></li>
<li>接头有突出的T，上述操作的DNA双链末端有突出的A，恰能配对。通过连接酶将接头连接上到DNA上；</li>
<li>NEBNext接头是一个U碱基在中间的环形接头，连接上DNA后将U碱基删除，从而形成“Y形“末端；</li>
<li>接头添加的目的是作为引物实现这些序列的扩增：文库index（Barcode）、PCR引物Rd1 SP/Rd2 SP，以及和测序平台互补的寡核苷酸链扩增（P7、P5）【其中与P5端连接的Index称为Index 2，又称之为i5；与P7端连接的称为Index1，也称为i7】；</li>
<li>Y形接头的设计，确保了DNA链两端是不配对的碱基序列引物，从而能够结合不同寡核苷酸序列，实现PCR中DNA链两端不会结合同一段序列（index、PCR引物以及和测序平台互补的寡核苷酸链），为后面的桥式扩增做准备；</li>
<li>Illumina平台的测序技术为基于<strong>基因芯片的边合成边测序</strong>：在Illumina测序平台的流通池（Flow cell）表面（如下图），通过基因芯片技术交错固定了无数条分别文库接头中P5和P7互补的寡核苷酸链（即短核苷酸链），单链化的文库DNA片段进入流通池后，可以与表面的寡核苷酸结合，从而进入测序过程。<img src="/2024/02/05/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BD%AC%E5%BD%95%E7%BB%84%E6%B5%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/3.png" alt></li>
<li>由于单链DNA的另一端具有不同的接头序列，因此它可以与相邻的另一种寡核苷酸互补配对，从而进行”桥”式扩增。假设第一次配对的接头是P7，一旦复制完成并洗脱模板后，DNA顶端可以与相邻的P5接头互补配对，形成一个”桥”结构。然后，以P5为引物进行复制。复制完成后，再次解链，并与相邻的不同种类接头结合，以进行下一轮复制。这个过程不断重复。25-28个循环完成后，原来散布在表面的核苷酸序列变成散布的DNA簇【何为散布的核苷酸序列？即一开始结合在P5或者P7上的序列】；<img src="/2024/02/05/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%BD%AC%E5%BD%95%E7%BB%84%E6%B5%8B%E5%BA%8F%E6%8A%80%E6%9C%AF/4.png" alt></li>
<li>接着，再次解链线性化，切割并洗去连接在P5上的DNA链，只留下P7上的DNA单链【仅保留正向链，即一开始进入flowcell的模板链】；</li>
<li>边合成边测序技术：合成过程发出碱基特异荧光信号被捕捉，合成循环数决定读取长度，对于某一特定的DNA簇，相同的DNA链会被同时读取【为什么要用簇？是为了增强信号】。</li>
<li>接着测序index序列，从而提示样本来源；</li>
<li>我们接着进行模板链的另一端开始的测序，这一次也能同时完成index2的测序，双端测序有利于纠正首尾错配：步骤是再次桥式扩增（但一次循环就够了），然后如前测序；</li>
<li>测序完成，按照相同index进行分类，样本内具有相似base call的序列被聚类，正向和反向read被配为连续序列；</li>
<li>连续序列和参考基因组进行比对，确定基因和突变。</li>
</ol>
</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>&emsp;&emsp;对实验原理的透彻理解，是数据分析的基础。后续的归一化、标准化等数据清洗要求都是建立在实验原理上。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/282790878">第二章：NGS原理解析01：二代测序流程 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/371040548#:~:text=Index%20%E5%8F%88%E7%A7%B0%20Barcode,%EF%BC%8C%E6%98%AF%E6%88%91%E4%BB%AC%E8%BF%9B%E8%A1%8C%20%E6%96%87%E5%BA%93%E6%B7%B7%E5%90%88%E6%B5%8B%E5%BA%8F%E6%97%B6%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%8B%86%E5%88%86%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A0%87%E7%AD%BE%20%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%8EP5%E7%AB%AF%E8%BF%9E%E6%8E%A5%E7%9A%84Index%E7%A7%B0%E4%B8%BAIndex%202%EF%BC%8C%E5%8F%88%E7%A7%B0%E4%B9%8B%E4%B8%BAi5%EF%BC%9B%E4%B8%8EP7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%A7%B0%E4%B8%BAIndex1%EF%BC%8C%E4%B9%9F%E7%A7%B0%E4%B8%BAi7%E3%80%82">干货 | Index这件小事，你get了吗？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://microbeonline.com/next-generation-sequencing/">Next Generation Sequencing: Principle, Steps Involved, and Applications • Microbe Online</a></li>
<li><a href="https://www.thermofisher.com/us/en/home/life-science/cloning/cloning-learning-center/invitrogen-school-of-molecular-biology/next-generation-sequencing/illumina-workflow.html">Next-Generation Sequencing Illumina Workflow–4 Key Steps | Thermo Fisher Scientific - US</a></li>
</ol>
]]></content>
      <categories>
        <category>生物信息学</category>
      </categories>
      <tags>
        <tag>生物信息学</tag>
        <tag>转录组学</tag>
      </tags>
  </entry>
  <entry>
    <title>生物信息学笔记（三）：基因定量</title>
    <url>/2024/02/16/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%9F%BA%E5%9B%A0%E5%AE%9A%E9%87%8F/</url>
    <content><![CDATA[<h2 id="为什么要对进行基因定量"><a href="#为什么要对进行基因定量" class="headerlink" title="为什么要对进行基因定量"></a>为什么要对进行基因定量</h2><p>&emsp;&emsp;转录组数据分析中，一个转录本反转录后的cDNA会被打碎成片段测序并和基因组比对，就会导致长转录本在给定的cDNA长度下可能会映射更多的cDNA，也就是说基因长度会影响Reads数。<br>&emsp;&emsp;测序深度是指测序过程中每个碱基被测序的平均次数，其计算公式为：$\frac{Reads数*Read长度}{参考序列长度}$：例如，对长100bp的目标区域进行捕获测序：采用单端测序，每个read长5bp；总共得到了200个reads；把所有的reads比对到目标区域后，100bp的目标区域中有98bp的位置至少有1个read覆盖到，换言之，剩余的2bp没有1个read覆盖。则测序深度为 200 x 5 / 100 = 10 我们说这此测序的深度为10X。显而易见，若测序越深，则对于相同长度的转录本，测序所得的Reads数更多。<br>&emsp;&emsp;综上所述，测序深度、基因长度和Reads数相关，所以需要在最终基因表达计数中去除相应的影响。注意，在基因定量的过程中，可能会由于样本本身的原因，如某个基因Reads数过高，导致基因定量后其他基因的表达量低于实际情况，这也是基因定量过程中需要去考虑的。</p>
<h2 id="Raw-count"><a href="#Raw-count" class="headerlink" title="Raw count"></a>Raw count</h2><p>&emsp;&emsp;所谓Raw count，又称为count数，和上一部分所说的Reads数是同一概念，是指和参考序列比对上的序列数目。原始的读取计数矩阵使用Raw count作为基础，但由于不同基因的长度和测序深度存在差异，因此无法直接比较。为了消除技术偏差的影响并赋予后续差异分析以统计学意义，需要对这些基因计数矩阵进行标准化处理，将其转化为相对值。<br>&emsp;&emsp;但注意，我们进行基因定量时需要充分考虑测序技术和原理，如在 10x 基因组学基因表达检测中，每个转录本都标有作为唯一分子标识符 （unique molecular identifier，UMI） 的序列。这些 UMI 能够准确定量基因表达水平，因为我们可以分辨出哪些读段是从同一个 mRNA 分子中产生的。因此，Cell Ranger 和 Space Ranger 执行 UMI 计数（不是读取计数）以测量基因表达水平，并且所有二次分析步骤都基于 UMI 计数执行。在传统的RNA-seq数据中，完整的转录本被片段化，然后进行cDNA合成、末端修复和衔接连接。在此工作流程中，从长转录本中采样片段的概率高于从短转录本中采样的概率。因此，按转录本长度（例如，TPM、RPKM、FPKM）对读取计数进行归一化是有意义的。然而，在 10x 基因表达测定中，这种基因长度偏差并不存在。因此，不建议按基因长度对UMI计数进行归一化。</p>
<h2 id="RPKM-FPKM"><a href="#RPKM-FPKM" class="headerlink" title="RPKM/FPKM"></a>RPKM/FPKM</h2><p>&emsp;&emsp;RPKM (Reads Per Kilobase of exon model per Million mapped reads)：每千个碱基的转录每百万映射读取的reads数，是针对单端测序的基因定量方法；FPKM (Fragment Per Kilobase of transcript, per Million mapped reads)：每千碱基片段每百万映射读取的 reads 数，是针对双端测序的基因定量方法。<br>&emsp;&emsp;以RPKM为例，其操作方法为：</p>
<ol>
<li>计算样本中的总读数，然后将该数字除以 1,000,000——这是“每百万”比例因子；</li>
<li>将读取计数除以“每百万”比例因子。这针对测序深度进行了归一化，得到每百万次读数（reads per million，RPM）；</li>
<li>将 RPM 值除以基因的长度，以千碱基为单位，得到RPKM。</li>
</ol>
<p>&emsp;&emsp;在第二代测序过程中，常采用一种方法将DNA分子打碎成片段（fragment），然后进行测序。在单末端测序中，每个片段对应一个读取序列（Read），而在双末端测序中，每个片段将从两个端点分别进行测序。因此，这两个成对的读取序列对应于同一个片段（虽然偶尔会出现只有一个读取序列与某个片段相对应的情况，这是由于某些原因导致另一个读取序列被排除或丢失了）。在这一点上存在着区别，对于FPKM（每百万片段计数）这一测量指标而言，与同一片段相关联的两个读取序列只被计算为一个读取序列。换句话说，FPKM是基于片段计数，而不是基于读取序列数量计算的，其他计算方法完全相同。<br>&emsp;&emsp;两者计算公式如下：</p>
<script type="math/tex; mode=display">FPKM = \frac{Read\quad counts}{Mapped\quad reads(Millions)\quad \times \quad Transcript\quad length(KB)}</script><script type="math/tex; mode=display">RPKM = \frac{Read\quad counts(Fragments)}{Mapped\quad reads(Millions)\quad \times \quad Transcript\quad length(KB)}</script><h2 id="TPM"><a href="#TPM" class="headerlink" title="TPM"></a>TPM</h2><p>&emsp;&emsp;TPM（Transcripts Per Million） 是一种常用的基因表达量归一化方法，它将基因的表达量调整为每百万条转录本的数量。TPM 值考虑了基因的长度和测序深度，通过将每个基因的 Counts 值除以其长度，并进行适当的归一化，将基因的表达量转换为每百万转录本数，以便进行样本间的比较和分析。TPM 值消除了样本间测序深度的差异和基因长度的影响，实质上，TPM相当于重新标准化的文库，保证每个样本中所有TPM的总和是相同的。TPM 与 RPKM 和 FPKM 非常相似。唯一的区别是操作顺序。以下是计算 TPM 的方法：</p>
<ol>
<li>将读取计数除以每个基因的长度（以千碱基为单位），得到每千碱基读数（reads per kilobase，RPK）；</li>
<li>计算样本中的所有 RPK 值的和，并将此数字除以 1,000,000，得到如前的“每百万”比例因子；</li>
<li>将 RPK 值除以“每百万”比例因子，得到TPM。</li>
</ol>
<p>&emsp;&emsp;综上，在计算TPM时，和前述指标唯一的区别是你首先对基因长度进行归一化，然后对测序深度进行归一化。然而，这种差异的影响是相当深远的。<br>&emsp;&emsp;使用 TPM 时，每个示例中所有 TPM 的总和是相同的。这样可以更容易地比较每个样品中映射到基因的reads比例。相比之下，使用RPKM和FPKM，每个样本中归一化读数的总和可能不同，这使得直接比较样本变得更加困难，在某种意义上，TPM降低了样本本身的影响，从而让样本具有可比性，即TPM实际上改进了RPKM/FPKM方法在跨样品间定量的不准确性。<br>&emsp;&emsp;其计算公式如下：</p>
<script type="math/tex; mode=display">TPM = 10^6 \times \frac{\frac {Read\quad counts}{Transcript \quad length(KB)}}{\Sigma \frac {Read\quad counts}{Transcript \quad length(KB)}}</script><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><ol>
<li>如前所述，基于测序计数选择基因定量的方案，如对于10×测序，直接使用原始Count即可；</li>
<li>对于传统的二代测序，应当进行标准化基因定量：<ol>
<li>RPKM和FPKM已经不推荐使用（参考：<a href="https://pubmed.ncbi.nlm.nih.gov/22872506/">Measurement of mRNA abundance using RNA-seq data: RPKM measure is inconsistent among samples</a>；<a href="https://academic.oup.com/bib/article/14/6/671/189645">comprehensive evaluation of normalization methods for Illumina high-throughput RNA sequencing data analysis</a>）；</li>
<li>TPM、DESeq适合组间比较，有研究更推荐DESeq进行组间比较（<a href="https://academic.oup.com/bib/article/14/6/671/189645#1808405">comprehensive evaluation of normalization methods for Illumina high-throughput RNA sequencing data analysis</a>；<a href="https://translational-medicine.biomedcentral.com/articles/10.1186/s12967-021-02936-w#Sec21">TPM, FPKM, or Normalized Counts? A Comparative Study of Quantification Measures for the Analysis of RNA-seq Data from the NCI Patient-Derived Models Repository</a>）。</li>
</ol>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://pubmed.ncbi.nlm.nih.gov/22872506/">Measurement of mRNA abundance using RNA-seq data: RPKM measure is inconsistent among samples</a></li>
<li><a href="https://academic.oup.com/bib/article/14/6/671/189645">comprehensive evaluation of normalization methods for Illumina high-throughput RNA sequencing data analysis</a></li>
<li><a href="https://translational-medicine.biomedcentral.com/articles/10.1186/s12967-021-02936-w#Sec21">TPM, FPKM, or Normalized Counts? A Comparative Study of Quantification Measures for the Analysis of RNA-seq Data from the NCI Patient-Derived Models Repository</a></li>
<li><a href="https://kb.10xgenomics.com/hc/en-us/articles/115003684783-Should-I-calculate-TPM-RPKM-or-FPKM-instead-of-counts-for-10x-Genomics-data">Should I calculate TPM, RPKM or FPKM, instead of counts for 10x Genomics data? – 10X Genomics</a></li>
<li><a href="https://www.rna-seqblog.com/rpkm-fpkm-and-tpm-clearly-explained/">RPKM, FPKM and TPM, clearly explained | RNA-Seq Blog</a></li>
</ol>
]]></content>
      <categories>
        <category>生物信息学</category>
      </categories>
      <tags>
        <tag>生物信息学</tag>
        <tag>转录组学</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>生物信息学笔记（二）：数据变换</title>
    <url>/2024/02/07/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="数据变换基本概念"><a href="#数据变换基本概念" class="headerlink" title="数据变换基本概念"></a>数据变换基本概念</h2><p>&emsp;&emsp;在数据科学中，数据变换是指对原始数据进行一系列操作或转换，从而使得数据更适合用于特定的分析或建模任务。其目的是提取有用的信息、减少噪声、改善模型的性能或满足模型假设。<strong>数据变换可以将一些我们理论上未解决的模型问题转化为已经解决的问题</strong>。<br>&emsp;&emsp;从变量个数的角度，数据变换分为单变量变换和多变量变换。多变量变换和特征工程的范畴有交叉，主要包括特征抽取、数据分解和维度压缩等方法。单变量变换分为线性和非线性变换。<br>&emsp;&emsp;本文讲解的数据变换都是连续变量的变换，着重关注单变量变换。</p>
<h2 id="归一化、标准化——容易混淆和误用的概念"><a href="#归一化、标准化——容易混淆和误用的概念" class="headerlink" title="归一化、标准化——容易混淆和误用的概念"></a>归一化、标准化——容易混淆和误用的概念</h2><p>&emsp;&emsp;归一化和标准化是数据变换的具体方法，在概念上是平行的：</p>
<ol>
<li>归一化（Normalization）：将数据按比例缩放，使其值落在特定的范围内。归一化的目的是消除不同特征之间的量纲差异，使得它们具有可比性，并且能够更好地适应某些机器学习算法。</li>
<li>标准化（Standardization）：将数据变换为均值为0，标准差为1的分布，但并非一定是正态的。</li>
</ol>
<p>&emsp;&emsp;许多教程和书籍认为标准化是归一化的一种，实际上归一化强调数据变换到特定的区间，而标准化则如上所述，强调给定的均值和标准差；另有误认为标准化能够实现标准正态分布，事实上要求源数据满足正态分布，否则只是满足给定均值和标准差的任何一种分布。这里要肯定一点，标准化会改变分布类型，但不会改变分布的种类。举例而言，对于足够样本数量的滴度数据两两比较依然要求取对数，以满足正态分布，进而采用t检验，而不是标准化采用t检验（原则上是Z检验）；若想使用Z检验，则遵循先取对数，再标准化的路径。<br>&emsp;&emsp;总而言之，“标准化必然得到N(0, 1)“的表述是错误的。<br>&emsp;&emsp;归一化同样不改变数据的分布种类，事实上，归一化和标准化同为线性变换，均不会改变分布种类，不会改变数据点的相对排位。上面提到有把标准化归类为归一化，实际上平行归类于线性变换更为妥当。<br>&emsp;&emsp;当原始数据的不同维度特征具有不一致的尺度或量纲时，需要对数据进行标准化或归一化处理。然而，并非所有的模型都需要进行归一化处理。例如，某些模型算法并不涉及距离度量或变量间标准差的衡量。例如，决策树算法并没有与距离相关的计算，因此在构建决策树模型时通常不需要对变量进行标准化。此外，概率模型通常不需要归一化，因为它们关注的是变量的分布和变量之间的条件概率，而不是变量的具体值。<br>&emsp;&emsp;然而，如果对处理后的数据的范围有严格要求，那么归一化是必要的。另外，如果数据不稳定，存在极端的最大或最小值，那么归一化也不适用。在机器学习中，标准化是一种更通用的方法。当存在不确定性时，可以直接使用标准化方法。<br>&emsp;&emsp;在分类和聚类算法中，如果需要使用距离来度量相似性，或者使用PCA技术进行降维，标准化的效果更好。而在不涉及距离度量和协方差计算的情况下，可以使用归一化方法。因此，在选择标准化还是归一化方法时，需要考虑具体的模型和算法，并根据需要进行选择。</p>
<h2 id="取对数——重要的偏态数据变换方法"><a href="#取对数——重要的偏态数据变换方法" class="headerlink" title="取对数——重要的偏态数据变换方法"></a>取对数——重要的偏态数据变换方法</h2><p>&emsp;&emsp;取对数通常在以下情况下使用：</p>
<ol>
<li>数据偏斜：当数据呈现偏斜分布时，即存在长尾或偏离正态分布的情况，可以考虑使用对数变换。对数变换可以减小数据的偏斜程度，使其更接近正态分布，从而提高模型的性能；</li>
<li>数据幅度差异较大：当数据的幅度差异较大时，例如某些特征的取值范围远远大于其他特征，这可能导致模型对取值较大的特征更为敏感，而忽略了其他特征的影响。在这种情况下，可以考虑使用对数变换来缩小幅度差异，使数据的取值范围更加接近，从而平衡各个特征的影响；</li>
<li>数据呈现指数增长或指数衰减：当数据随着自变量的增长或减小呈现指数级别的变化时，可以使用对数变换来线性化数据。对数变换可以将指数增长或衰减的趋势转化为线性趋势，使得建模更加便捷和准确。</li>
</ol>
<p>&emsp;&emsp;显而易见，其目的是：</p>
<ol>
<li>压缩数据的幅度：对数变换可以将大幅度的数据压缩到较小的范围内，使得数据更易于处理和可视化。</li>
<li>缩小数据的差异：对数变换可以减小数据之间的差异，使得各个数据点更接近，有助于降低异常值的影响。</li>
<li>线性化关系：对数变换可以将指数关系转化为线性关系，使得数据更符合线性建模的假设，从而简化建模过程。取对数的操作能够尽可能满足经典线性回归假设：<ol>
<li>避免共线性；</li>
<li>避免异方差；</li>
<li>尽可能符合正态分布。</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;人们通过诸如Box-cox等典型方法积极探索各种数据变换方式，这表明数据变换并非一成不变的规约，而更像是一门根据实践经验进行灵活操作的艺术。我们需要仔细考虑数据分布的特点，以确定最合适的变换方法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>特征</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>归一化</td>
<td>Min-max scaler， MaxAbs scaler</td>
<td>将数据分别映射到[0,1]和[-1,1]</td>
</tr>
<tr>
<td>标准化</td>
<td>Standard scaler</td>
<td>转换为均值为0，方差为1的分布</td>
</tr>
<tr>
<td>Sigmoid转换</td>
<td>Sigmoid transformation</td>
<td>映射成为[0,1]的值</td>
</tr>
<tr>
<td>Log transformation</td>
<td>Log transformation</td>
<td>让数据符合我们所做的假设，让能够在已有理论上对其分析</td>
</tr>
<tr>
<td>Box-cox变换</td>
<td>Box-cox transformation</td>
<td>用来把非正态的分布变成正态分布</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zhuanlan.zhihu.com/p/497099039">常用数据转换方式 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/qq_43466427/article/details/86571215">第十三讲 数据变换-CSDN博客</a></li>
</ol>
]]></content>
      <categories>
        <category>生物信息学</category>
      </categories>
      <tags>
        <tag>生物信息学</tag>
        <tag>统计学</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>记录的目的</title>
    <url>/2023/10/11/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9B%AE%E7%9A%84/</url>
    <content><![CDATA[<p>&emsp;&emsp;我是一个普通的医学生，没有系统的计算机训练，没有系统学习数学课程。</p>
<p>&emsp;&emsp;为啥会对这一切感兴趣，在上一个笔记里面说过啦~ <a href="https://forrestgump618.github.io/2023/10/04/%E4%B8%80%E8%B5%B7%E6%9D%A5%E6%84%9F%E5%8F%97%E6%95%B0%E6%8D%AE%E4%B9%8B%E7%BE%8E%E5%90%A7%EF%BC%81/">一起来感受数据之美吧！ | 一个夏天的年少 (forrestgump618.github.io)</a></p>
<p>&emsp;&emsp;从不了解生信、统计，到自己真正涉猎，我花了很长时间。获取这些知识的过程是非常不易的。</p>
<p>&emsp;&emsp;而当自己真正去解决相关问题的时候，才发现更不方便的还在后面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时会为了一个公式的使用从bing查到google，从文献查到专著，最狠的一次是查了50篇文献结果大家都对此语焉不详；</span><br><span class="line">很多事情花了大把的时间但最后并没有结果，甚至考试月也是如此；</span><br><span class="line">越向下学发现数学知识成为阻碍进步的门槛；</span><br><span class="line">化用太多的方法发现自己思考的很少，会怀疑自己的意义。</span><br><span class="line">…………</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;许多个日夜，真希望有个人能将我想知道的问题放在了网上。<br>&emsp;&emsp;很多时候，国内网站搜不到的问题都能在bing和google上搜到。<br>&emsp;&emsp;在知识上，很佩服老外们的分享能力。</p>
<p>&emsp;&emsp;印象最深的是和一位国外大咖的请教，在极短的时间内回复了邮件，估摸着大概是凌晨的2点钟。让我十分惶恐隔了许久才回信。</p>
<p>&emsp;&emsp;太多的时候，不是知识抽象。而是一座大厦建立起来，需要有个人告诉你，这个大厦里面哪个电梯可以到哪。<br>&emsp;&emsp;但太多时候，独自在大厦的摸索中，看到更多的是抽象名词所累积起来的水泥板。<br>&emsp;&emsp;有幸还有些走过的人给你插个指向标。</p>
<p>&emsp;&emsp;因此我在想，我把我自己的用过的方法，想过的事情，分享出来，让一些想获取类似问题解答方法的人能够获得启发。</p>
<p>&emsp;&emsp;而一点点私心是，找个小站安放自己。</p>
<p>&emsp;&emsp;我的学习之路是踩着别人的石头过来的，希望自己也能够给需要的人带来一些帮助~</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>统计学</tag>
        <tag>交叉学科</tag>
      </tags>
  </entry>
</search>
